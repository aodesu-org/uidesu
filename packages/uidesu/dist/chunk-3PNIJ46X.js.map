{"version":3,"sources":["../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/utils.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/helpers/miscellaneous.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/helpers/webidl.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/simple-queue.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/abstract-ops/internal-methods.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/generic-reader.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/stub/number-isfinite.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/stub/math-trunc.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/basic.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/readable-stream.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/default-reader.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/target/es2018/stub/async-iterator-prototype.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/async-iterator.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/stub/number-isnan.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/abstract-ops/ecmascript.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/abstract-ops/miscellaneous.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/abstract-ops/queue-with-sizes.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/helpers/array-buffer-view.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/reader-options.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/abstract-ops/queuing-strategy.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/underlying-sink.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/writable-stream.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/abort-signal.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/writable-stream.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/globals.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/stub/dom-exception.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/pipe.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/tee.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/readable-stream-like.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream/from.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/underlying-source.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/iterator-options.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/pipe-options.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/readable-writable-pair.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/readable-stream.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy-init.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/byte-length-queuing-strategy.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/count-queuing-strategy.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/validators/transformer.ts","../../../node_modules/.pnpm/web-streams-polyfill@3.3.3/node_modules/web-streams-polyfill/src/lib/transform-stream.ts","../../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/streams.cjs","../../../node_modules/.pnpm/node-domexception@1.0.0/node_modules/node-domexception/index.js","../../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/index.js","../../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/file.js","../../../node_modules/.pnpm/formdata-polyfill@4.0.10/node_modules/formdata-polyfill/esm.min.js","../../../node_modules/.pnpm/fetch-blob@3.2.0/node_modules/fetch-blob/from.js"],"names":["noop","typeIsObject","x","rethrowAssertionErrorRejection","setFunctionName","fn","name","originalPromise","originalPromiseThen","originalPromiseReject","newPromise","executor","promiseResolvedWith","value","resolve","promiseRejectedWith","reason","PerformPromiseThen","promise","onFulfilled","onRejected","uponPromise","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","_queueMicrotask","callback","resolvedPromise","cb","reflectCall","F","V","args","promiseCall","QUEUE_MAX_ARRAY_SIZE","SimpleQueue","element","oldBack","newBack","oldFront","newFront","oldCursor","newCursor","elements","i","node","front","cursor","AbortSteps","ErrorSteps","CancelSteps","PullSteps","ReleaseSteps","ReadableStreamReaderGenericInitialize","reader","stream","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","reject","defaultReaderClosedPromiseResolve","NumberIsFinite","MathTrunc","v","isDictionary","assertDictionary","obj","context","assertFunction","isObject","assertObject","assertRequiredArgument","position","assertRequiredField","field","convertUnrestrictedDouble","censorNegativeZero","integerPart","convertUnsignedLongLongWithEnforceRange","upperBound","assertReadableStream","IsReadableStream","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","ReadableStreamFulfillReadRequest","chunk","done","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","IsReadableStreamLocked","defaultReaderBrandCheckException","resolvePromise","rejectPromise","ReadableStreamDefaultReaderRead","e","ReadableStreamDefaultReaderRelease","ReadableStreamDefaultReaderErrorReadRequests","readRequests","AsyncIteratorPrototype","ReadableStreamAsyncIteratorImpl","preventCancel","nextSteps","returnSteps","queueMicrotask","result","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","streamAsyncIteratorBrandCheckException","AcquireReadableStreamAsyncIterator","impl","iterator","NumberIsNaN","CreateArrayFromList","CopyDataBlockBytes","dest","destOffset","src","srcOffset","n","TransferArrayBuffer","O","buffer","IsDetachedBuffer","ArrayBufferSlice","begin","end","length","slice","GetMethod","receiver","prop","func","CreateAsyncFromSyncIterator","syncIteratorRecord","syncIterable","asyncIterator","nextMethod","SymbolAsyncIterator","_c","_a","_b","GetIterator","hint","method","syncMethod","IteratorNext","iteratorRecord","IteratorComplete","iterResult","IteratorValue","IsNonNegativeNumber","CloneAsUint8Array","DequeueValue","container","pair","EnqueueValueWithSize","size","PeekQueueValue","ResetQueue","isDataViewConstructor","ctor","isDataView","view","arrayBufferViewElementSize","ReadableStreamBYOBRequest","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","bytesWritten","ReadableByteStreamControllerRespond","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","IsReadableByteStreamController","byteStreamControllerBrandCheckException","ReadableByteStreamControllerGetBYOBRequest","ReadableByteStreamControllerGetDesiredSize","state","ReadableByteStreamControllerClose","ReadableByteStreamControllerEnqueue","ReadableByteStreamControllerError","ReadableByteStreamControllerClearPendingPullIntos","ReadableByteStreamControllerClearAlgorithms","ReadableByteStreamControllerFillReadRequestFromQueue","autoAllocateChunkSize","bufferE","pullIntoDescriptor","ReadableByteStreamControllerCallPullIfNeeded","firstPullInto","controller","ReadableByteStreamControllerShouldCallPull","pullPromise","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableStreamFulfillReadIntoRequest","bytesFilled","elementSize","ReadableByteStreamControllerEnqueueChunkToQueue","byteOffset","byteLength","ReadableByteStreamControllerEnqueueClonedChunkToQueue","clonedChunk","cloneE","ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue","firstDescriptor","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","maxBytesToCopy","maxBytesFilled","totalBytesToCopyRemaining","ready","remainderBytes","maxAlignedBytes","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerHandleQueueDrain","ReadableStreamClose","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerProcessReadRequestsUsingQueue","ReadableByteStreamControllerPullInto","min","readIntoRequest","minimumFill","ReadableStreamAddReadIntoRequest","emptyView","ReadableByteStreamControllerRespondInClosedState","ReadableStreamHasBYOBReader","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerRespondInReadableState","remainderSize","ReadableByteStreamControllerRespondInternal","firstPendingPullInto","transferredBuffer","transferredView","ReadableStreamError","entry","byobRequest","SetUpReadableStreamBYOBRequest","viewByteLength","SetUpReadableByteStreamController","startAlgorithm","pullAlgorithm","cancelAlgorithm","highWaterMark","startResult","r","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","request","convertReaderOptions","options","mode","convertReadableStreamReaderMode","convertByobReadOptions","AcquireReadableStreamBYOBReader","ReadableStreamBYOBReader","IsReadableStreamBYOBReader","byobReaderBrandCheckException","rawOptions","ReadableStreamBYOBReaderRead","ReadableStreamBYOBReaderRelease","ReadableStreamBYOBReaderErrorReadIntoRequests","readIntoRequests","ExtractHighWaterMark","strategy","defaultHWM","ExtractSizeAlgorithm","convertQueuingStrategy","init","convertQueuingStrategySize","convertUnderlyingSink","original","abort","close","start","type","write","convertUnderlyingSinkAbortCallback","convertUnderlyingSinkCloseCallback","convertUnderlyingSinkStartCallback","convertUnderlyingSinkWriteCallback","assertWritableStream","IsWritableStream","isAbortSignal","supportsAbortController","createAbortController","WritableStream","rawUnderlyingSink","rawStrategy","underlyingSink","InitializeWritableStream","sizeAlgorithm","SetUpWritableStreamDefaultControllerFromUnderlyingSink","streamBrandCheckException","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","CreateWritableStream","writeAlgorithm","closeAlgorithm","abortAlgorithm","WritableStreamDefaultController","SetUpWritableStreamDefaultController","wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","WritableStreamDefaultControllerClose","WritableStreamAddWriteRequest","writeRequest","WritableStreamDealWithRejection","error","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","storedError","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamFinishInFlightClose","defaultWriterClosedPromiseResolve","WritableStreamFinishInFlightCloseWithError","WritableStreamMarkCloseRequestInFlight","WritableStreamMarkFirstWriteRequestInFlight","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseReset","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterGetDesiredSize","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterCloseWithErrorPropagation","WritableStreamDefaultWriterEnsureClosedPromiseRejected","defaultWriterClosedPromiseResetToRejected","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","WritableStreamDefaultControllerGetDesiredSize","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","WritableStreamDefaultControllerWrite","closeSentinel","IsWritableStreamDefaultController","defaultControllerBrandCheckException","WritableStreamDefaultControllerError","WritableStreamDefaultControllerClearAlgorithms","WritableStreamDefaultControllerGetBackpressure","startPromise","WritableStreamDefaultControllerAdvanceQueueIfNeeded","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","enqueueE","WritableStreamDefaultControllerProcessClose","WritableStreamDefaultControllerProcessWrite","sinkClosePromise","sinkWritePromise","getGlobals","globals","isDOMExceptionConstructor","getFromGlobal","createPolyfill","message","DOMException","ReadableStreamPipeTo","source","preventClose","preventAbort","signal","shuttingDown","currentWrite","actions","shutdownWithAction","action","pipeLoop","resolveLoop","rejectLoop","next","pipeStep","resolveRead","rejectRead","isOrBecomesErrored","shutdown","isOrBecomesClosed","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","ReadableStreamDefaultController","IsReadableStreamDefaultController","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerClearAlgorithms","ReadableStreamDefaultControllerCallPullIfNeeded","ReadableStreamDefaultControllerShouldCallPull","ReadableStreamDefaultControllerHasBackpressure","SetUpReadableStreamDefaultController","SetUpReadableStreamDefaultControllerFromUnderlyingSource","underlyingSource","ReadableStreamTee","cloneForBranch2","ReadableByteStreamTee","ReadableStreamDefaultTee","reading","readAgain","canceled1","canceled2","reason1","reason2","branch1","branch2","resolveCancelPromise","cancelPromise","chunk1","chunk2","cancel1Algorithm","compositeReason","cancelResult","cancel2Algorithm","CreateReadableStream","readAgainForBranch1","readAgainForBranch2","forwardReaderError","thisReader","pullWithDefaultReader","pull1Algorithm","pull2Algorithm","pullWithBYOBReader","forBranch2","byobBranch","otherBranch","byobCanceled","otherCanceled","CreateReadableByteStream","isReadableStreamLike","ReadableStreamFrom","ReadableStreamFromDefaultReader","ReadableStreamFromIterable","asyncIterable","nextResult","nextPromise","returnMethod","returnResult","returnPromise","readPromise","readResult","convertUnderlyingDefaultOrByteSource","cancel","pull","convertUnderlyingSourceCancelCallback","convertUnderlyingSourcePullCallback","convertUnderlyingSourceStartCallback","convertReadableStreamType","convertIteratorOptions","convertPipeOptions","assertAbortSignal","convertReadableWritablePair","readable","writable","ReadableStream","rawUnderlyingSource","InitializeReadableStream","rawTransform","transform","destination","branches","sourceCancelPromise","convertQueuingStrategyInit","byteLengthSizeFunction","ByteLengthQueuingStrategy","IsByteLengthQueuingStrategy","byteLengthBrandCheckException","countSizeFunction","CountQueuingStrategy","IsCountQueuingStrategy","countBrandCheckException","convertTransformer","flush","readableType","writableType","convertTransformerCancelCallback","convertTransformerFlushCallback","convertTransformerStartCallback","convertTransformerTransformCallback","TransformStream","rawTransformer","rawWritableStrategy","rawReadableStrategy","writableStrategy","readableStrategy","transformer","readableHighWaterMark","readableSizeAlgorithm","writableHighWaterMark","writableSizeAlgorithm","startPromise_resolve","InitializeTransformStream","SetUpTransformStreamDefaultControllerFromTransformer","IsTransformStream","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSourcePullAlgorithm","TransformStreamDefaultSourceCancelAlgorithm","TransformStreamSetBackpressure","TransformStreamError","TransformStreamErrorWritableAndUnblockWrite","TransformStreamDefaultControllerClearAlgorithms","TransformStreamUnblockWrite","TransformStreamDefaultController","IsTransformStreamDefaultController","readableController","TransformStreamDefaultControllerEnqueue","TransformStreamDefaultControllerError","TransformStreamDefaultControllerTerminate","SetUpTransformStreamDefaultController","transformAlgorithm","flushAlgorithm","transformResultE","TransformStreamDefaultControllerPerformTransform","transformPromise","backpressureChangePromise","defaultControllerFinishPromiseReject","defaultControllerFinishPromiseResolve","flushPromise","require_streams","__commonJSMin","process","wt","emitWarning","Blob","params","blob","ctrl","require_node_domexception","exports","module","MessageChannel","port","ab","err","In","POOL_SIZE","toIterator","parts","clone","part","b","_Blob","#parts","#type","#size","#endings","blobParts","encoder","decoder","str","data","offset","it","relativeStart","relativeEnd","span","added","object","fetch_blob_default","_File","#lastModified","#name","fileBits","fileName","lastModified","File","file_default","t","h","m","f","a","c","FormData","#d","o","l","d","formDataToBlob","B","p","stat","fs"],"mappings":"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","file":"chunk-3PNIJ46X.js","sourcesContent":["export function noop(): undefined {\n  return undefined;\n}\n","import { noop } from '../../utils';\nimport { AssertionError } from '../../stub/assert';\n\nexport function typeIsObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport const rethrowAssertionErrorRejection: (e: any) => void =\n  DEBUG ? e => {\n    // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n    // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n    // expect any errors, but assertion errors are always problematic.\n    if (e && e instanceof AssertionError) {\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    }\n  } : noop;\n\nexport function setFunctionName(fn: Function, name: string): void {\n  try {\n    Object.defineProperty(fn, 'name', {\n      value: name,\n      configurable: true\n    });\n  } catch {\n    // This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n  }\n}\n","import { rethrowAssertionErrorRejection } from './miscellaneous';\nimport assert from '../../stub/assert';\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\n\n// https://webidl.spec.whatwg.org/#a-new-promise\nexport function newPromise<T>(executor: (\n  resolve: (value: T | PromiseLike<T>) => void,\n  reject: (reason?: any) => void\n) => void): Promise<T> {\n  return new originalPromise(executor);\n}\n\n// https://webidl.spec.whatwg.org/#a-promise-resolved-with\nexport function promiseResolvedWith<T>(value: T | PromiseLike<T>): Promise<T> {\n  return newPromise(resolve => resolve(value));\n}\n\n// https://webidl.spec.whatwg.org/#a-promise-rejected-with\nexport function promiseRejectedWith<T = never>(reason: any): Promise<T> {\n  return originalPromiseReject(reason);\n}\n\nexport function PerformPromiseThen<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n  // approximation.\n  return originalPromiseThen.call(promise, onFulfilled, onRejected) as Promise<TResult1 | TResult2>;\n}\n\n// Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned\n// from that handler. To prevent this, return null instead of void from all handlers.\n// http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\nexport function uponPromise<T>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => null | PromiseLike<null>,\n  onRejected?: (reason: any) => null | PromiseLike<null>): void {\n  PerformPromiseThen(\n    PerformPromiseThen(promise, onFulfilled, onRejected),\n    undefined,\n    rethrowAssertionErrorRejection\n  );\n}\n\nexport function uponFulfillment<T>(promise: Promise<T>, onFulfilled: (value: T) => null | PromiseLike<null>): void {\n  uponPromise(promise, onFulfilled);\n}\n\nexport function uponRejection(promise: Promise<unknown>, onRejected: (reason: any) => null | PromiseLike<null>): void {\n  uponPromise(promise, undefined, onRejected);\n}\n\nexport function transformPromiseWith<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  fulfillmentHandler?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  rejectionHandler?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\n\nexport function setPromiseIsHandledToTrue(promise: Promise<unknown>): void {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\nlet _queueMicrotask: (callback: () => void) => void = callback => {\n  if (typeof queueMicrotask === 'function') {\n    _queueMicrotask = queueMicrotask;\n  } else {\n    const resolvedPromise = promiseResolvedWith(undefined);\n    _queueMicrotask = cb => PerformPromiseThen(resolvedPromise, cb);\n  }\n  return _queueMicrotask(callback);\n};\n\nexport { _queueMicrotask as queueMicrotask };\n\nexport function reflectCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R, V: T, args: A): R {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexport function promiseCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R | PromiseLike<R>,\n                                                   V: T,\n                                                   args: A): Promise<R> {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return promiseResolvedWith(reflectCall(F, V, args));\n  } catch (value) {\n    return promiseRejectedWith(value);\n  }\n}\n","import assert from '../stub/assert';\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n\ninterface Node<T> {\n  _elements: T[];\n  _next: Node<T> | undefined;\n}\n\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nexport class SimpleQueue<T> {\n  private _front: Node<T>;\n  private _back: Node<T>;\n  private _cursor = 0;\n  private _size = 0;\n\n  constructor() {\n    // _front and _back are always defined.\n    this._front = {\n      _elements: [],\n      _next: undefined\n    };\n    this._back = this._front;\n    // The cursor is used to avoid calling Array.shift().\n    // It contains the index of the front element of the array inside the\n    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n    this._cursor = 0;\n    // When there is only one node, size === elements.length - cursor.\n    this._size = 0;\n  }\n\n  get length(): number {\n    return this._size;\n  }\n\n  // For exception safety, this method is structured in order:\n  // 1. Read state\n  // 2. Calculate required state mutations\n  // 3. Perform state mutations\n  push(element: T): void {\n    const oldBack = this._back;\n    let newBack = oldBack;\n    assert(oldBack._next === undefined);\n    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n      newBack = {\n        _elements: [],\n        _next: undefined\n      };\n    }\n\n    // push() is the mutation most likely to throw an exception, so it\n    // goes first.\n    oldBack._elements.push(element);\n    if (newBack !== oldBack) {\n      this._back = newBack;\n      oldBack._next = newBack;\n    }\n    ++this._size;\n  }\n\n  // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  // exception safety.\n  shift(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const oldFront = this._front;\n    let newFront = oldFront;\n    const oldCursor = this._cursor;\n    let newCursor = oldCursor + 1;\n\n    const elements = oldFront._elements;\n    const element = elements[oldCursor];\n\n    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n      assert(elements.length === QUEUE_MAX_ARRAY_SIZE);\n      assert(oldFront._next !== undefined);\n      newFront = oldFront._next!;\n      newCursor = 0;\n    }\n\n    // No mutations before this point.\n    --this._size;\n    this._cursor = newCursor;\n    if (oldFront !== newFront) {\n      this._front = newFront;\n    }\n\n    // Permit shifted element to be garbage collected.\n    elements[oldCursor] = undefined!;\n\n    return element;\n  }\n\n  // The tricky thing about forEach() is that it can be called\n  // re-entrantly. The queue may be mutated inside the callback. It is easy to\n  // see that push() within the callback has no negative effects since the end\n  // of the queue is checked for on every iteration. If shift() is called\n  // repeatedly within the callback then the next iteration may return an\n  // element that has been removed. In this case the callback will be called\n  // with undefined values until we either \"catch up\" with elements that still\n  // exist or reach the back of the queue.\n  forEach(callback: (element: T) => void): void {\n    let i = this._cursor;\n    let node = this._front;\n    let elements = node._elements;\n    while (i !== elements.length || node._next !== undefined) {\n      if (i === elements.length) {\n        assert(node._next !== undefined);\n        assert(i === QUEUE_MAX_ARRAY_SIZE);\n        node = node._next!;\n        elements = node._elements;\n        i = 0;\n        if (elements.length === 0) {\n          break;\n        }\n      }\n      callback(elements[i]);\n      ++i;\n    }\n  }\n\n  // Return the element that would be returned if shift() was called now,\n  // without modifying the queue.\n  peek(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const front = this._front;\n    const cursor = this._cursor;\n    return front._elements[cursor];\n  }\n}\n","export const AbortSteps = Symbol('[[AbortSteps]]');\nexport const ErrorSteps = Symbol('[[ErrorSteps]]');\nexport const CancelSteps = Symbol('[[CancelSteps]]');\nexport const PullSteps = Symbol('[[PullSteps]]');\nexport const ReleaseSteps = Symbol('[[ReleaseSteps]]');\n","import assert from '../../stub/assert';\nimport { ReadableStream, ReadableStreamCancel, type ReadableStreamReader } from '../readable-stream';\nimport { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\nimport { ReleaseSteps } from '../abstract-ops/internal-methods';\n\nexport function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nexport function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined> {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nexport function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>) {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  assert(stream._reader === reader);\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  }\n\n  stream._readableStreamController[ReleaseSteps]();\n\n  stream._reader = undefined;\n  reader._ownerReadableStream = undefined!;\n}\n\n// Helper functions for the readers.\n\nexport function readerLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nexport function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>) {\n  reader._closedPromise = newPromise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nexport function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n}\n\nexport function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any) {\n  if (reader._closedPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nexport function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>) {\n  if (reader._closedPromise_resolve === undefined) {\n    return;\n  }\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite: typeof Number.isFinite = Number.isFinite || function (x) {\n  return typeof x === 'number' && isFinite(x);\n};\n\nexport default NumberIsFinite;\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc: typeof Math.trunc = Math.trunc || function (v) {\n  return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\nexport default MathTrunc;\n","import NumberIsFinite from '../../stub/number-isfinite';\nimport MathTrunc from '../../stub/math-trunc';\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nexport function isDictionary(x: any): x is object | null {\n  return typeof x === 'object' || typeof x === 'function';\n}\n\nexport function assertDictionary(obj: unknown,\n                                 context: string): asserts obj is object | null | undefined {\n  if (obj !== undefined && !isDictionary(obj)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport type AnyFunction = (...args: any[]) => any;\n\n// https://heycam.github.io/webidl/#idl-callback-functions\nexport function assertFunction(x: unknown, context: string): asserts x is AnyFunction {\n  if (typeof x !== 'function') {\n    throw new TypeError(`${context} is not a function.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-object\nexport function isObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport function assertObject(x: unknown,\n                             context: string): asserts x is object {\n  if (!isObject(x)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport function assertRequiredArgument<T>(x: T | undefined,\n                                          position: number,\n                                          context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n  }\n}\n\nexport function assertRequiredField<T>(x: T | undefined,\n                                       field: string,\n                                       context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`${field} is required in '${context}'.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nexport function convertUnrestrictedDouble(value: unknown): number {\n  return Number(value);\n}\n\nfunction censorNegativeZero(x: number): number {\n  return x === 0 ? 0 : x;\n}\n\nfunction integerPart(x: number): number {\n  return censorNegativeZero(MathTrunc(x));\n}\n\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nexport function convertUnsignedLongLongWithEnforceRange(value: unknown, context: string): number {\n  const lowerBound = 0;\n  const upperBound = Number.MAX_SAFE_INTEGER;\n\n  let x = Number(value);\n  x = censorNegativeZero(x);\n\n  if (!NumberIsFinite(x)) {\n    throw new TypeError(`${context} is not a finite number`);\n  }\n\n  x = integerPart(x);\n\n  if (x < lowerBound || x > upperBound) {\n    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n  }\n\n  if (!NumberIsFinite(x) || x === 0) {\n    return 0;\n  }\n\n  // TODO Use BigInt if supported?\n  // let xBigInt = BigInt(integerPart(x));\n  // xBigInt = BigInt.asUintN(64, xBigInt);\n  // return Number(xBigInt);\n\n  return x;\n}\n","import { IsReadableStream, ReadableStream } from '../readable-stream';\n\nexport function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream {\n  if (!IsReadableStream(x)) {\n    throw new TypeError(`${context} is not a ReadableStream.`);\n  }\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { PullSteps } from '../abstract-ops/internal-methods';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\n\n/**\n * A result returned by {@link ReadableStreamDefaultReader.read}.\n *\n * @public\n */\nexport type ReadableStreamDefaultReadResult<T> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value?: undefined;\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamDefaultReader<R>(stream: ReadableStream): ReadableStreamDefaultReader<R> {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadRequest<R>(stream: ReadableStream<R>,\n                                                readRequest: ReadRequest<R>): void {\n  assert(IsReadableStreamDefaultReader(stream._reader));\n  assert(stream._state === 'readable');\n\n  (stream._reader! as ReadableStreamDefaultReader<R>)._readRequests.push(readRequest);\n}\n\nexport function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean) {\n  const reader = stream._reader as ReadableStreamDefaultReader<R>;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift()!;\n  if (done) {\n    readRequest._closeSteps();\n  } else {\n    readRequest._chunkSteps(chunk!);\n  }\n}\n\nexport function ReadableStreamGetNumReadRequests<R>(stream: ReadableStream<R>): number {\n  return (stream._reader as ReadableStreamDefaultReader<R>)._readRequests.length;\n}\n\nexport function ReadableStreamHasDefaultReader(stream: ReadableStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamDefaultReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadRequest<R> {\n  _chunkSteps(chunk: R): void;\n\n  _closeSteps(): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamDefaultReader<R = any> {\n  /** @internal */\n  _ownerReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readRequests: SimpleQueue<ReadRequest<R>>;\n\n  constructor(stream: ReadableStream<R>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed,\n   * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamDefaultReaderRead(this, readRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamDefaultReader(this)) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    ReadableStreamDefaultReaderRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nsetFunctionName(ReadableStreamDefaultReader.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStreamDefaultReader.prototype.read, 'read');\nsetFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, 'releaseLock');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultReader;\n}\n\nexport function ReadableStreamDefaultReaderRead<R>(reader: ReadableStreamDefaultReader<R>,\n                                                   readRequest: ReadRequest<R>): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    readRequest._closeSteps();\n  } else if (stream._state === 'errored') {\n    readRequest._errorSteps(stream._storedError);\n  } else {\n    assert(stream._state === 'readable');\n    stream._readableStreamController[PullSteps](readRequest as ReadRequest<any>);\n  }\n}\n\nexport function ReadableStreamDefaultReaderRelease(reader: ReadableStreamDefaultReader) {\n  ReadableStreamReaderGenericRelease(reader);\n  const e = new TypeError('Reader was released');\n  ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n}\n\nexport function ReadableStreamDefaultReaderErrorReadRequests(reader: ReadableStreamDefaultReader, e: any) {\n  const readRequests = reader._readRequests;\n  reader._readRequests = new SimpleQueue();\n  readRequests.forEach(readRequest => {\n    readRequest._errorSteps(e);\n  });\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n","/// <reference lib=\"es2018.asynciterable\" />\n\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const AsyncIteratorPrototype: AsyncIterable<any> =\n  Object.getPrototypeOf(Object.getPrototypeOf(async function* (): AsyncIterableIterator<any> {}).prototype);\n","/// <reference lib=\"es2018.asynciterable\" />\n\nimport { ReadableStream } from '../readable-stream';\nimport {\n  AcquireReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  type ReadableStreamDefaultReadResult,\n  type ReadRequest\n} from './default-reader';\nimport { ReadableStreamReaderGenericCancel, ReadableStreamReaderGenericRelease } from './generic-reader';\nimport assert from '../../stub/assert';\nimport { AsyncIteratorPrototype } from '@@target/stub/async-iterator-prototype';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  queueMicrotask,\n  transformPromiseWith\n} from '../helpers/webidl';\n\n/**\n * An async iterator returned by {@link ReadableStream.values}.\n *\n * @public\n */\nexport interface ReadableStreamAsyncIterator<R> extends AsyncIterableIterator<R> {\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nexport class ReadableStreamAsyncIteratorImpl<R> {\n  private readonly _reader: ReadableStreamDefaultReader<R>;\n  private readonly _preventCancel: boolean;\n  private _ongoingPromise: Promise<ReadableStreamDefaultReadResult<R>> | undefined = undefined;\n  private _isFinished = false;\n\n  constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean) {\n    this._reader = reader;\n    this._preventCancel = preventCancel;\n  }\n\n  next(): Promise<ReadableStreamDefaultReadResult<R>> {\n    const nextSteps = () => this._nextSteps();\n    this._ongoingPromise = this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n      nextSteps();\n    return this._ongoingPromise;\n  }\n\n  return(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    const returnSteps = () => this._returnSteps(value);\n    return this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n      returnSteps();\n  }\n\n  private _nextSteps(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value: undefined, done: true });\n    }\n\n    const reader = this._reader;\n    assert(reader._ownerReadableStream !== undefined);\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        this._ongoingPromise = undefined;\n        // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n        // FIXME Is this a bug in the specification, or in the test?\n        queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n      },\n      _closeSteps: () => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        resolvePromise({ value: undefined, done: true });\n      },\n      _errorSteps: reason => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        rejectPromise(reason);\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n    return promise;\n  }\n\n  private _returnSteps(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value, done: true });\n    }\n    this._isFinished = true;\n\n    const reader = this._reader;\n    assert(reader._ownerReadableStream !== undefined);\n    assert(reader._readRequests.length === 0);\n\n    if (!this._preventCancel) {\n      const result = ReadableStreamReaderGenericCancel(reader, value);\n      ReadableStreamReaderGenericRelease(reader);\n      return transformPromiseWith(result, () => ({ value, done: true }));\n    }\n\n    ReadableStreamReaderGenericRelease(reader);\n    return promiseResolvedWith({ value, done: true });\n  }\n}\n\ninterface ReadableStreamAsyncIteratorInstance<R> extends ReadableStreamAsyncIterator<R> {\n  /** @interal */\n  _asyncIteratorImpl: ReadableStreamAsyncIteratorImpl<R>;\n\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nconst ReadableStreamAsyncIteratorPrototype: ReadableStreamAsyncIteratorInstance<any> = {\n  next(this: ReadableStreamAsyncIteratorInstance<any>): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n    }\n    return this._asyncIteratorImpl.next();\n  },\n\n  return(this: ReadableStreamAsyncIteratorInstance<any>, value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n    }\n    return this._asyncIteratorImpl.return(value);\n  }\n} as any;\nObject.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamAsyncIterator<R>(stream: ReadableStream<R>,\n                                                      preventCancel: boolean): ReadableStreamAsyncIterator<R> {\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n  const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  const iterator: ReadableStreamAsyncIteratorInstance<R> = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorImpl = impl;\n  return iterator;\n}\n\nfunction IsReadableStreamAsyncIterator<R = any>(x: any): x is ReadableStreamAsyncIterator<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n    return false;\n  }\n\n  try {\n    // noinspection SuspiciousTypeOfGuard\n    return (x as ReadableStreamAsyncIteratorInstance<any>)._asyncIteratorImpl instanceof\n      ReadableStreamAsyncIteratorImpl;\n  } catch {\n    return false;\n  }\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamAsyncIteratorBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n","/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN: typeof Number.isNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n","import { reflectCall } from 'lib/helpers/webidl';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport assert from '../../stub/assert';\n\ndeclare global {\n  interface ArrayBuffer {\n    readonly detached: boolean;\n\n    transfer(): ArrayBuffer;\n  }\n\n  function structuredClone<T>(value: T, options: { transfer: ArrayBuffer[] }): T;\n}\n\nexport function CreateArrayFromList<T extends any[]>(elements: T): T {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice() as T;\n}\n\nexport function CopyDataBlockBytes(dest: ArrayBuffer,\n                                   destOffset: number,\n                                   src: ArrayBuffer,\n                                   srcOffset: number,\n                                   n: number) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n\nexport let TransferArrayBuffer = (O: ArrayBuffer): ArrayBuffer => {\n  if (typeof O.transfer === 'function') {\n    TransferArrayBuffer = buffer => buffer.transfer();\n  } else if (typeof structuredClone === 'function') {\n    TransferArrayBuffer = buffer => structuredClone(buffer, { transfer: [buffer] });\n  } else {\n    // Not implemented correctly\n    TransferArrayBuffer = buffer => buffer;\n  }\n  return TransferArrayBuffer(O);\n};\n\nexport function CanTransferArrayBuffer(O: ArrayBuffer): boolean {\n  return !IsDetachedBuffer(O);\n}\n\nexport let IsDetachedBuffer = (O: ArrayBuffer): boolean => {\n  if (typeof O.detached === 'boolean') {\n    IsDetachedBuffer = buffer => buffer.detached;\n  } else {\n    // Not implemented correctly\n    IsDetachedBuffer = buffer => buffer.byteLength === 0;\n  }\n  return IsDetachedBuffer(O);\n};\n\nexport function ArrayBufferSlice(buffer: ArrayBuffer, begin: number, end: number): ArrayBuffer {\n  // ArrayBuffer.prototype.slice is not available on IE10\n  // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n  if (buffer.slice) {\n    return buffer.slice(begin, end);\n  }\n  const length = end - begin;\n  const slice = new ArrayBuffer(length);\n  CopyDataBlockBytes(slice, 0, buffer, begin, length);\n  return slice;\n}\n\nexport type MethodName<T> = {\n  [P in keyof T]: T[P] extends Function | undefined ? P : never;\n}[keyof T];\n\nexport function GetMethod<T, K extends MethodName<T>>(receiver: T, prop: K): T[K] | undefined {\n  const func = receiver[prop];\n  if (func === undefined || func === null) {\n    return undefined;\n  }\n  if (typeof func !== 'function') {\n    throw new TypeError(`${String(prop)} is not a function`);\n  }\n  return func;\n}\n\nexport interface SyncIteratorRecord<T> {\n  iterator: Iterator<T>,\n  nextMethod: Iterator<T>['next'],\n  done: boolean;\n}\n\nexport interface AsyncIteratorRecord<T> {\n  iterator: AsyncIterator<T>,\n  nextMethod: AsyncIterator<T>['next'],\n  done: boolean;\n}\n\nexport type SyncOrAsyncIteratorRecord<T> = SyncIteratorRecord<T> | AsyncIteratorRecord<T>;\n\nexport function CreateAsyncFromSyncIterator<T>(syncIteratorRecord: SyncIteratorRecord<T>): AsyncIteratorRecord<T> {\n  // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,\n  // we use yield* inside an async generator function to achieve the same result.\n\n  // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.\n  const syncIterable = {\n    [Symbol.iterator]: () => syncIteratorRecord.iterator\n  };\n  // Create an async generator function and immediately invoke it.\n  const asyncIterator = (async function* () {\n    return yield* syncIterable;\n  }());\n  // Return as an async iterator record.\n  const nextMethod = asyncIterator.next;\n  return { iterator: asyncIterator, nextMethod, done: false };\n}\n\n// Aligns with core-js/modules/es.symbol.async-iterator.js\nexport const SymbolAsyncIterator: (typeof Symbol)['asyncIterator'] =\n  Symbol.asyncIterator ??\n  Symbol.for?.('Symbol.asyncIterator') ??\n  '@@asyncIterator';\n\nexport type SyncOrAsyncIterable<T> = Iterable<T> | AsyncIterable<T>;\nexport type SyncOrAsyncIteratorMethod<T> = () => (Iterator<T> | AsyncIterator<T>);\n\nfunction GetIterator<T>(\n  obj: SyncOrAsyncIterable<T>,\n  hint: 'async',\n  method?: SyncOrAsyncIteratorMethod<T>\n): AsyncIteratorRecord<T>;\nfunction GetIterator<T>(\n  obj: Iterable<T>,\n  hint: 'sync',\n  method?: SyncOrAsyncIteratorMethod<T>\n): SyncIteratorRecord<T>;\nfunction GetIterator<T>(\n  obj: SyncOrAsyncIterable<T>,\n  hint = 'sync',\n  method?: SyncOrAsyncIteratorMethod<T>\n): SyncOrAsyncIteratorRecord<T> {\n  assert(hint === 'sync' || hint === 'async');\n  if (method === undefined) {\n    if (hint === 'async') {\n      method = GetMethod(obj as AsyncIterable<T>, SymbolAsyncIterator);\n      if (method === undefined) {\n        const syncMethod = GetMethod(obj as Iterable<T>, Symbol.iterator);\n        const syncIteratorRecord = GetIterator(obj as Iterable<T>, 'sync', syncMethod);\n        return CreateAsyncFromSyncIterator(syncIteratorRecord);\n      }\n    } else {\n      method = GetMethod(obj as Iterable<T>, Symbol.iterator);\n    }\n  }\n  if (method === undefined) {\n    throw new TypeError('The object is not iterable');\n  }\n  const iterator = reflectCall(method, obj, []);\n  if (!typeIsObject(iterator)) {\n    throw new TypeError('The iterator method must return an object');\n  }\n  const nextMethod = iterator.next;\n  return { iterator, nextMethod, done: false } as SyncOrAsyncIteratorRecord<T>;\n}\n\nexport { GetIterator };\n\nexport function IteratorNext<T>(iteratorRecord: AsyncIteratorRecord<T>): Promise<IteratorResult<T>> {\n  const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);\n  if (!typeIsObject(result)) {\n    throw new TypeError('The iterator.next() method must return an object');\n  }\n  return result;\n}\n\nexport function IteratorComplete<TReturn>(\n  iterResult: IteratorResult<unknown, TReturn>\n): iterResult is IteratorReturnResult<TReturn> {\n  assert(typeIsObject(iterResult));\n  return Boolean(iterResult.done);\n}\n\nexport function IteratorValue<T>(iterResult: IteratorYieldResult<T>): T {\n  assert(typeIsObject(iterResult));\n  return iterResult.value;\n}\n","import NumberIsNaN from '../../stub/number-isnan';\nimport { ArrayBufferSlice } from './ecmascript';\nimport type { NonShared } from '../helpers/array-buffer-view';\n\nexport function IsNonNegativeNumber(v: number): boolean {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (NumberIsNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function CloneAsUint8Array(O: NonShared<ArrayBufferView>): NonShared<Uint8Array> {\n  const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n  return new Uint8Array(buffer) as NonShared<Uint8Array>;\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsNonNegativeNumber } from './miscellaneous';\n\nexport interface QueueContainer<T> {\n  _queue: SimpleQueue<T>;\n  _queueTotalSize: number;\n}\n\nexport interface QueuePair<T> {\n  value: T;\n  size: number;\n}\n\nexport function DequeueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift()!;\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n}\n\nexport function EnqueueValueWithSize<T>(container: QueueContainer<QueuePair<T>>, value: T, size: number) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  if (!IsNonNegativeNumber(size) || size === Infinity) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n}\n\nexport function PeekQueueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.peek();\n  return pair.value;\n}\n\nexport function ResetQueue<T>(container: QueueContainer<T>) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = new SimpleQueue<T>();\n  container._queueTotalSize = 0;\n}\n","export type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Float32Array\n  | Float64Array;\n\nexport type NonShared<T extends ArrayBufferView> = T & {\n  buffer: ArrayBuffer;\n}\n\nexport interface ArrayBufferViewConstructor<T extends ArrayBufferView = ArrayBufferView> {\n  new(buffer: ArrayBuffer, byteOffset: number, length?: number): T;\n\n  readonly prototype: T;\n}\n\nexport interface TypedArrayConstructor<T extends TypedArray = TypedArray> extends ArrayBufferViewConstructor<T> {\n  readonly BYTES_PER_ELEMENT: number;\n}\n\nexport type DataViewConstructor = ArrayBufferViewConstructor<DataView>;\n\nfunction isDataViewConstructor(ctor: Function): ctor is DataViewConstructor {\n  return ctor === DataView;\n}\n\nexport function isDataView(view: ArrayBufferView): view is DataView {\n  return isDataViewConstructor(view.constructor);\n}\n\nexport function arrayBufferViewElementSize<T extends ArrayBufferView>(ctor: ArrayBufferViewConstructor<T>): number {\n  if (isDataViewConstructor(ctor)) {\n    return 1;\n  }\n  return (ctor as unknown as TypedArrayConstructor).BYTES_PER_ELEMENT;\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  IsReadableStreamDefaultReader,\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadableStreamHasDefaultReader,\n  type ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamAddReadIntoRequest,\n  ReadableStreamFulfillReadIntoRequest,\n  ReadableStreamGetNumReadIntoRequests,\n  ReadableStreamHasBYOBReader,\n  type ReadIntoRequest\n} from './byob-reader';\nimport NumberIsInteger from '../../stub/number-isinteger';\nimport {\n  IsReadableStreamLocked,\n  type ReadableByteStream,\n  ReadableStreamClose,\n  ReadableStreamError\n} from '../readable-stream';\nimport type { ValidatedUnderlyingByteSource } from './underlying-source';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport {\n  ArrayBufferSlice,\n  CanTransferArrayBuffer,\n  CopyDataBlockBytes,\n  IsDetachedBuffer,\n  TransferArrayBuffer\n} from '../abstract-ops/ecmascript';\nimport { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\nimport { assertRequiredArgument, convertUnsignedLongLongWithEnforceRange } from '../validators/basic';\nimport {\n  type ArrayBufferViewConstructor,\n  arrayBufferViewElementSize,\n  type NonShared,\n  type TypedArrayConstructor\n} from '../helpers/array-buffer-view';\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nexport class ReadableStreamBYOBRequest {\n  /** @internal */\n  _associatedReadableByteStreamController!: ReadableByteStreamController;\n  /** @internal */\n  _view!: NonShared<ArrayBufferView> | null;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n   */\n  get view(): ArrayBufferView | null {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   *\n   * After this method is called, {@link ReadableStreamBYOBRequest.view | view} will be transferred and no longer\n   * modifiable.\n   */\n  respond(bytesWritten: number): void;\n  respond(bytesWritten: number | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respond');\n    }\n    assertRequiredArgument(bytesWritten, 1, 'respond');\n    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view!.buffer)) {\n      throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n    }\n\n    assert(this._view!.byteLength > 0);\n    assert(this._view!.buffer.byteLength > 0);\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that instead of writing into\n   * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n   * which will be given to the consumer of the readable byte stream.\n   *\n   * After this method is called, `view` will be transferred and no longer modifiable.\n   */\n  respondWithNewView(view: ArrayBufferView): void;\n  respondWithNewView(view: NonShared<ArrayBufferView>): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respondWithNewView');\n    }\n    assertRequiredArgument(view, 1, 'respondWithNewView');\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(view.buffer)) {\n      throw new TypeError('The given view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n  respond: { enumerable: true },\n  respondWithNewView: { enumerable: true },\n  view: { enumerable: true }\n});\nsetFunctionName(ReadableStreamBYOBRequest.prototype.respond, 'respond');\nsetFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, 'respondWithNewView');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBRequest',\n    configurable: true\n  });\n}\n\ninterface ByteQueueElement {\n  buffer: ArrayBuffer;\n  byteOffset: number;\n  byteLength: number;\n}\n\ntype PullIntoDescriptor<T extends NonShared<ArrayBufferView> = NonShared<ArrayBufferView>> =\n  DefaultPullIntoDescriptor\n  | BYOBPullIntoDescriptor<T>;\n\ninterface DefaultPullIntoDescriptor {\n  buffer: ArrayBuffer;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  minimumFill: number;\n  elementSize: number;\n  viewConstructor: TypedArrayConstructor<Uint8Array>;\n  readerType: 'default' | 'none';\n}\n\ninterface BYOBPullIntoDescriptor<T extends NonShared<ArrayBufferView> = NonShared<ArrayBufferView>> {\n  buffer: ArrayBuffer;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  minimumFill: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<T>;\n  readerType: 'byob' | 'none';\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableByteStreamController {\n  /** @internal */\n  _controlledReadableByteStream!: ReadableByteStream;\n  /** @internal */\n  _queue!: SimpleQueue<ByteQueueElement>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n  /** @internal */\n  _autoAllocateChunkSize: number | undefined;\n  /** @internal */\n  _byobRequest: ReadableStreamBYOBRequest | null;\n  /** @internal */\n  _pendingPullIntos!: SimpleQueue<PullIntoDescriptor>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the current BYOB pull request, or `null` if there isn't one.\n   */\n  get byobRequest(): ReadableStreamBYOBRequest | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    return ReadableByteStreamControllerGetBYOBRequest(this);\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk chunk in the controlled readable stream.\n   * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n   */\n  enqueue(chunk: ArrayBufferView): void;\n  enqueue(chunk: NonShared<ArrayBufferView>): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    assertRequiredArgument(chunk, 1, 'enqueue');\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('chunk must be an array buffer view');\n    }\n    if (chunk.byteLength === 0) {\n      throw new TypeError('chunk must have non-zero byteLength');\n    }\n    if (chunk.buffer.byteLength === 0) {\n      throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<NonShared<Uint8Array>>): void {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream));\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n      return;\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer: ArrayBuffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        readRequest._errorSteps(bufferE);\n        return;\n      }\n\n      const pullIntoDescriptor: DefaultPullIntoDescriptor = {\n        buffer,\n        bufferByteLength: autoAllocateChunkSize,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        minimumFill: 1,\n        elementSize: 1,\n        viewConstructor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    ReadableStreamAddReadRequest(stream, readRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n  }\n\n  /** @internal */\n  [ReleaseSteps](): void {\n    if (this._pendingPullIntos.length > 0) {\n      const firstPullInto = this._pendingPullIntos.peek();\n      firstPullInto.readerType = 'none';\n\n      this._pendingPullIntos = new SimpleQueue();\n      this._pendingPullIntos.push(firstPullInto);\n    }\n  }\n}\n\nObject.defineProperties(ReadableByteStreamController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  byobRequest: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(ReadableByteStreamController.prototype.close, 'close');\nsetFunctionName(ReadableByteStreamController.prototype.enqueue, 'enqueue');\nsetFunctionName(ReadableByteStreamController.prototype.error, 'error');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {\n    value: 'ReadableByteStreamController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nexport function IsReadableByteStreamController(x: any): x is ReadableByteStreamController {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableByteStreamController;\n}\n\nfunction IsReadableStreamBYOBRequest(x: any): x is ReadableStreamBYOBRequest {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBRequest;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller: ReadableByteStreamController): void {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n\n      return null;\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n      return null;\n    }\n  );\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller: ReadableByteStreamController) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor<T extends NonShared<ArrayBufferView>>(\n  stream: ReadableByteStream,\n  pullIntoDescriptor: PullIntoDescriptor<T>\n) {\n  assert(stream._state !== 'errored');\n  assert(pullIntoDescriptor.readerType !== 'none');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView as unknown as NonShared<Uint8Array>, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor<T extends NonShared<ArrayBufferView>>(\n  pullIntoDescriptor: PullIntoDescriptor<T>\n): T {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.viewConstructor(\n    pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize) as T;\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller: ReadableByteStreamController,\n                                                         buffer: ArrayBuffer,\n                                                         byteOffset: number,\n                                                         byteLength: number) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller: ReadableByteStreamController,\n                                                               buffer: ArrayBuffer,\n                                                               byteOffset: number,\n                                                               byteLength: number) {\n  let clonedChunk;\n  try {\n    clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);\n  } catch (cloneE) {\n    ReadableByteStreamControllerError(controller, cloneE);\n    throw cloneE;\n  }\n  ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);\n}\n\nfunction ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller: ReadableByteStreamController,\n                                                                    firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.readerType === 'none');\n  if (firstDescriptor.bytesFilled > 0) {\n    ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n      controller,\n      firstDescriptor.buffer,\n      firstDescriptor.byteOffset,\n      firstDescriptor.bytesFilled\n    );\n  }\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller: ReadableByteStreamController,\n                                                                     pullIntoDescriptor: PullIntoDescriptor) {\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n  const maxAlignedBytes = maxBytesFilled - remainderBytes;\n  // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n  // of the queue, so the underlying source can keep filling it.\n  if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue.peek();\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller: ReadableByteStreamController,\n                                                                size: number,\n                                                                pullIntoDescriptor: PullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos.peek() === pullIntoDescriptor);\n  assert(controller._byobRequest === null);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller: ReadableByteStreamController) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller: ReadableByteStreamController) {\n  if (controller._byobRequest === null) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined!;\n  controller._byobRequest._view = null!;\n  controller._byobRequest = null;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller: ReadableByteStreamController) {\n  assert(!controller._closeRequested);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n    assert(pullIntoDescriptor.readerType !== 'none');\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller: ReadableByteStreamController) {\n  const reader = controller._controlledReadableByteStream._reader;\n  assert(IsReadableStreamDefaultReader(reader));\n  while (reader._readRequests.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n    const readRequest = reader._readRequests.shift();\n    ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n  }\n}\n\nexport function ReadableByteStreamControllerPullInto<T extends NonShared<ArrayBufferView>>(\n  controller: ReadableByteStreamController,\n  view: T,\n  min: number,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = controller._controlledReadableByteStream;\n\n  const ctor = view.constructor as ArrayBufferViewConstructor<T>;\n  const elementSize = arrayBufferViewElementSize(ctor);\n\n  const { byteOffset, byteLength } = view;\n\n  const minimumFill = min * elementSize;\n  assert(minimumFill >= elementSize && minimumFill <= byteLength);\n  assert(minimumFill % elementSize === 0);\n\n  let buffer: ArrayBuffer;\n  try {\n    buffer = TransferArrayBuffer(view.buffer);\n  } catch (e) {\n    readIntoRequest._errorSteps(e);\n    return;\n  }\n\n  const pullIntoDescriptor: BYOBPullIntoDescriptor<T> = {\n    buffer,\n    bufferByteLength: buffer.byteLength,\n    byteOffset,\n    byteLength,\n    bytesFilled: 0,\n    minimumFill,\n    elementSize,\n    viewConstructor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    return;\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    readIntoRequest._closeSteps(emptyView);\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      readIntoRequest._chunkSteps(filledView);\n      return;\n    }\n\n    if (controller._closeRequested) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      readIntoRequest._errorSteps(e);\n      return;\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  ReadableStreamAddReadIntoRequest<T>(stream, readIntoRequest);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller: ReadableByteStreamController,\n                                                          firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.bytesFilled % firstDescriptor.elementSize === 0);\n\n  if (firstDescriptor.readerType === 'none') {\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n  }\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream)) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller: ReadableByteStreamController,\n                                                            bytesWritten: number,\n                                                            pullIntoDescriptor: PullIntoDescriptor) {\n  assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.readerType === 'none') {\n    ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    return;\n  }\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n    // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n    // of the queue, so the underlying source can keep filling it.\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    ReadableByteStreamControllerEnqueueClonedChunkToQueue(\n      controller,\n      pullIntoDescriptor.buffer,\n      end - remainderSize,\n      remainderSize\n    );\n  }\n\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller: ReadableByteStreamController, bytesWritten: number) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  assert(CanTransferArrayBuffer(firstDescriptor.buffer));\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  const state = controller._controlledReadableByteStream._state;\n  if (state === 'closed') {\n    assert(bytesWritten === 0);\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(state === 'readable');\n    assert(bytesWritten > 0);\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(\n  controller: ReadableByteStreamController\n): PullIntoDescriptor {\n  assert(controller._byobRequest === null);\n  const descriptor = controller._pendingPullIntos.shift()!;\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller: ReadableByteStreamController): boolean {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller: ReadableByteStreamController) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nexport function ReadableByteStreamControllerClose(controller: ReadableByteStreamController) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nexport function ReadableByteStreamControllerEnqueue(\n  controller: ReadableByteStreamController,\n  chunk: NonShared<ArrayBufferView>\n) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  const { buffer, byteOffset, byteLength } = chunk;\n  if (IsDetachedBuffer(buffer)) {\n    throw new TypeError('chunk\\'s buffer is detached and so cannot be enqueued');\n  }\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n      throw new TypeError(\n        'The BYOB request\\'s buffer has been detached and so cannot be filled with an enqueued chunk'\n      );\n    }\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n    if (firstPendingPullInto.readerType === 'none') {\n      ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n    }\n  }\n\n  if (ReadableStreamHasDefaultReader(stream)) {\n    ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      assert(controller._pendingPullIntos.length === 0);\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n      if (controller._pendingPullIntos.length > 0) {\n        assert(controller._pendingPullIntos.peek().readerType === 'default');\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n      }\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView as NonShared<Uint8Array>, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream)) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(!IsReadableStreamLocked(stream));\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableByteStreamControllerError(controller: ReadableByteStreamController, e: any) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableByteStreamControllerFillReadRequestFromQueue(\n  controller: ReadableByteStreamController,\n  readRequest: ReadRequest<NonShared<Uint8Array>>\n) {\n  assert(controller._queueTotalSize > 0);\n\n  const entry = controller._queue.shift();\n  controller._queueTotalSize -= entry.byteLength;\n\n  ReadableByteStreamControllerHandleQueueDrain(controller);\n\n  const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n  readRequest._chunkSteps(view as NonShared<Uint8Array>);\n}\n\nexport function ReadableByteStreamControllerGetBYOBRequest(\n  controller: ReadableByteStreamController\n): ReadableStreamBYOBRequest | null {\n  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const view = new Uint8Array(firstDescriptor.buffer,\n                                firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n    const byobRequest: ReadableStreamBYOBRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n    SetUpReadableStreamBYOBRequest(byobRequest, controller, view as NonShared<Uint8Array>);\n    controller._byobRequest = byobRequest;\n  }\n  return controller._byobRequest;\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller: ReadableByteStreamController): number | null {\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nexport function ReadableByteStreamControllerRespond(controller: ReadableByteStreamController, bytesWritten: number) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (bytesWritten === 0) {\n      throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n    }\n    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n      throw new RangeError('bytesWritten out of range');\n    }\n  }\n\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nexport function ReadableByteStreamControllerRespondWithNewView(controller: ReadableByteStreamController,\n                                                               view: NonShared<ArrayBufferView>) {\n  assert(controller._pendingPullIntos.length > 0);\n  assert(!IsDetachedBuffer(view.buffer));\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (view.byteLength !== 0) {\n      throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (view.byteLength === 0) {\n      throw new TypeError(\n        'The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream'\n      );\n    }\n  }\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n    throw new RangeError('The region specified by view is larger than byobRequest');\n  }\n\n  const viewByteLength = view.byteLength;\n  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n  ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n}\n\nexport function SetUpReadableByteStreamController(stream: ReadableByteStream,\n                                                  controller: ReadableByteStreamController,\n                                                  startAlgorithm: () => void | PromiseLike<void>,\n                                                  pullAlgorithm: () => Promise<void>,\n                                                  cancelAlgorithm: (reason: any) => Promise<void>,\n                                                  highWaterMark: number,\n                                                  autoAllocateChunkSize: number | undefined) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._byobRequest = null;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = new SimpleQueue();\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n      return null;\n    },\n    r => {\n      ReadableByteStreamControllerError(controller, r);\n      return null;\n    }\n  );\n}\n\nexport function SetUpReadableByteStreamControllerFromUnderlyingSource(\n  stream: ReadableByteStream,\n  underlyingByteSource: ValidatedUnderlyingByteSource,\n  highWaterMark: number\n) {\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let pullAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingByteSource.start !== undefined) {\n    startAlgorithm = () => underlyingByteSource.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingByteSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingByteSource.pull!(controller);\n  } else {\n    pullAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingByteSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingByteSource.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize === 0) {\n    throw new TypeError('autoAllocateChunkSize must be greater than 0');\n  }\n\n  SetUpReadableByteStreamController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize\n  );\n}\n\nfunction SetUpReadableStreamBYOBRequest(request: ReadableStreamBYOBRequest,\n                                        controller: ReadableByteStreamController,\n                                        view: NonShared<ArrayBufferView>) {\n  assert(IsReadableByteStreamController(controller));\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view));\n  assert(!IsDetachedBuffer(view.buffer));\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n","import { assertDictionary, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ReadableStreamGetReaderOptions,\n  ValidatedReadableStreamBYOBReaderReadOptions\n} from '../readable-stream/reader-options';\n\nexport function convertReaderOptions(options: ReadableStreamGetReaderOptions | null | undefined,\n                                     context: string): ReadableStreamGetReaderOptions {\n  assertDictionary(options, context);\n  const mode = options?.mode;\n  return {\n    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n  };\n}\n\nfunction convertReadableStreamReaderMode(mode: string, context: string): 'byob' {\n  mode = `${mode}`;\n  if (mode !== 'byob') {\n    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  }\n  return mode;\n}\n\nexport function convertByobReadOptions(\n  options: ReadableStreamBYOBReaderReadOptions | null | undefined,\n  context: string\n): ValidatedReadableStreamBYOBReaderReadOptions {\n  assertDictionary(options, context);\n  const min = options?.min ?? 1;\n  return {\n    min: convertUnsignedLongLongWithEnforceRange(\n      min,\n      `${context} has member 'min' that`\n    )\n  };\n}\n","import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, type ReadableByteStream, type ReadableStream } from '../readable-stream';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamController,\n  ReadableByteStreamControllerPullInto\n} from './byte-stream-controller';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\nimport { IsDetachedBuffer } from '../abstract-ops/ecmascript';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ValidatedReadableStreamBYOBReaderReadOptions\n} from './reader-options';\nimport { convertByobReadOptions } from '../validators/reader-options';\nimport { isDataView, type NonShared, type TypedArray } from '../helpers/array-buffer-view';\n\n/**\n * A result returned by {@link ReadableStreamBYOBReader.read}.\n *\n * @public\n */\nexport type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value: T | undefined;\n};\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamBYOBReader(stream: ReadableByteStream): ReadableStreamBYOBReader {\n  return new ReadableStreamBYOBReader(stream as ReadableStream<Uint8Array>);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadIntoRequest<T extends NonShared<ArrayBufferView>>(\n  stream: ReadableByteStream,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  assert(IsReadableStreamBYOBReader(stream._reader));\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  (stream._reader! as ReadableStreamBYOBReader)._readIntoRequests.push(readIntoRequest);\n}\n\nexport function ReadableStreamFulfillReadIntoRequest(stream: ReadableByteStream,\n                                                     chunk: ArrayBufferView,\n                                                     done: boolean) {\n  const reader = stream._reader as ReadableStreamBYOBReader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift()!;\n  if (done) {\n    readIntoRequest._closeSteps(chunk);\n  } else {\n    readIntoRequest._chunkSteps(chunk);\n  }\n}\n\nexport function ReadableStreamGetNumReadIntoRequests(stream: ReadableByteStream): number {\n  return (stream._reader as ReadableStreamBYOBReader)._readIntoRequests.length;\n}\n\nexport function ReadableStreamHasBYOBReader(stream: ReadableByteStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamBYOBReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadIntoRequest<T extends NonShared<ArrayBufferView>> {\n  _chunkSteps(chunk: T): void;\n\n  _closeSteps(chunk: T | undefined): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamBYOBReader {\n  /** @internal */\n  _ownerReadableStream!: ReadableByteStream;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readIntoRequests: SimpleQueue<ReadIntoRequest<any>>;\n\n  constructor(stream: ReadableStream<Uint8Array>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n        'source');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Attempts to reads bytes into view, and returns a promise resolved with the result.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read<T extends ArrayBufferView>(\n    view: T,\n    options?: ReadableStreamBYOBReaderReadOptions\n  ): Promise<ReadableStreamBYOBReadResult<T>>;\n  read<T extends NonShared<ArrayBufferView>>(\n    view: T,\n    rawOptions: ReadableStreamBYOBReaderReadOptions | null | undefined = {}\n  ): Promise<ReadableStreamBYOBReadResult<T>> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('read'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n    }\n    if (view.byteLength === 0) {\n      return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n    }\n    if (view.buffer.byteLength === 0) {\n      return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n    }\n    if (IsDetachedBuffer(view.buffer)) {\n      return promiseRejectedWith(new TypeError('view\\'s buffer has been detached'));\n    }\n\n    let options: ValidatedReadableStreamBYOBReaderReadOptions;\n    try {\n      options = convertByobReadOptions(rawOptions, 'options');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const min = options.min;\n    if (min === 0) {\n      return promiseRejectedWith(new TypeError('options.min must be greater than 0'));\n    }\n    if (!isDataView(view)) {\n      if (min > (view as unknown as TypedArray).length) {\n        return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s length'));\n      }\n    } else if (min > view.byteLength) {\n      return promiseRejectedWith(new RangeError('options.min must be less than or equal to view\\'s byteLength'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamBYOBReadResult<T>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamBYOBReadResult<T>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readIntoRequest: ReadIntoRequest<T> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    ReadableStreamBYOBReaderRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nsetFunctionName(ReadableStreamBYOBReader.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStreamBYOBReader.prototype.read, 'read');\nsetFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, 'releaseLock');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBReader;\n}\n\nexport function ReadableStreamBYOBReaderRead<T extends NonShared<ArrayBufferView>>(\n  reader: ReadableStreamBYOBReader,\n  view: T,\n  min: number,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    readIntoRequest._errorSteps(stream._storedError);\n  } else {\n    ReadableByteStreamControllerPullInto(\n      stream._readableStreamController as ReadableByteStreamController,\n      view,\n      min,\n      readIntoRequest\n    );\n  }\n}\n\nexport function ReadableStreamBYOBReaderRelease(reader: ReadableStreamBYOBReader) {\n  ReadableStreamReaderGenericRelease(reader);\n  const e = new TypeError('Reader was released');\n  ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n}\n\nexport function ReadableStreamBYOBReaderErrorReadIntoRequests(reader: ReadableStreamBYOBReader, e: any) {\n  const readIntoRequests = reader._readIntoRequests;\n  reader._readIntoRequests = new SimpleQueue();\n  readIntoRequests.forEach(readIntoRequest => {\n    readIntoRequest._errorSteps(e);\n  });\n}\n\n// Helper functions for the ReadableStreamBYOBReader.\n\nfunction byobReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n","import type { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport NumberIsNaN from '../../stub/number-isnan';\n\nexport function ExtractHighWaterMark(strategy: QueuingStrategy, defaultHWM: number): number {\n  const { highWaterMark } = strategy;\n\n  if (highWaterMark === undefined) {\n    return defaultHWM;\n  }\n\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('Invalid highWaterMark');\n  }\n\n  return highWaterMark;\n}\n\nexport function ExtractSizeAlgorithm<T>(strategy: QueuingStrategy<T>): QueuingStrategySizeCallback<T> {\n  const { size } = strategy;\n\n  if (!size) {\n    return () => 1;\n  }\n\n  return size;\n}\n","import type { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport { assertDictionary, assertFunction, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategy<T>(init: QueuingStrategy<T> | null | undefined,\n                                          context: string): QueuingStrategy<T> {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  const size = init?.size;\n  return {\n    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n  };\n}\n\nfunction convertQueuingStrategySize<T>(fn: QueuingStrategySizeCallback<T>,\n                                       context: string): QueuingStrategySizeCallback<T> {\n  assertFunction(fn, context);\n  return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n","import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport type {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from '../writable-stream/underlying-sink';\nimport { WritableStreamDefaultController } from '../writable-stream';\n\nexport function convertUnderlyingSink<W>(original: UnderlyingSink<W> | null,\n                                         context: string): ValidatedUnderlyingSink<W> {\n  assertDictionary(original, context);\n  const abort = original?.abort;\n  const close = original?.close;\n  const start = original?.start;\n  const type = original?.type;\n  const write = original?.write;\n  return {\n    abort: abort === undefined ?\n      undefined :\n      convertUnderlyingSinkAbortCallback(abort, original!, `${context} has member 'abort' that`),\n    close: close === undefined ?\n      undefined :\n      convertUnderlyingSinkCloseCallback(close, original!, `${context} has member 'close' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSinkStartCallback(start, original!, `${context} has member 'start' that`),\n    write: write === undefined ?\n      undefined :\n      convertUnderlyingSinkWriteCallback(write, original!, `${context} has member 'write' that`),\n    type\n  };\n}\n\nfunction convertUnderlyingSinkAbortCallback(\n  fn: UnderlyingSinkAbortCallback,\n  original: UnderlyingSink,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSinkCloseCallback(\n  fn: UnderlyingSinkCloseCallback,\n  original: UnderlyingSink,\n  context: string\n): () => Promise<void> {\n  assertFunction(fn, context);\n  return () => promiseCall(fn, original, []);\n}\n\nfunction convertUnderlyingSinkStartCallback(\n  fn: UnderlyingSinkStartCallback,\n  original: UnderlyingSink,\n  context: string\n): UnderlyingSinkStartCallback {\n  assertFunction(fn, context);\n  return (controller: WritableStreamDefaultController) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSinkWriteCallback<W>(\n  fn: UnderlyingSinkWriteCallback<W>,\n  original: UnderlyingSink<W>,\n  context: string\n): (chunk: W, controller: WritableStreamDefaultController) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: W, controller: WritableStreamDefaultController) => promiseCall(fn, original, [chunk, controller]);\n}\n","import { IsWritableStream, WritableStream } from '../writable-stream';\n\nexport function assertWritableStream(x: unknown, context: string): asserts x is WritableStream {\n  if (!IsWritableStream(x)) {\n    throw new TypeError(`${context} is not a WritableStream.`);\n  }\n}\n","/**\n * A signal object that allows you to communicate with a request and abort it if required\n * via its associated `AbortController` object.\n *\n * @remarks\n *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @public\n */\nexport interface AbortSignal {\n  /**\n   * Whether the request is aborted.\n   */\n  readonly aborted: boolean;\n\n  /**\n   * If aborted, returns the reason for aborting.\n   */\n  readonly reason?: any;\n\n  /**\n   * Add an event listener to be triggered when this signal becomes aborted.\n   */\n  addEventListener(type: 'abort', listener: () => void): void;\n\n  /**\n   * Remove an event listener that was previously added with {@link AbortSignal.addEventListener}.\n   */\n  removeEventListener(type: 'abort', listener: () => void): void;\n}\n\nexport function isAbortSignal(value: unknown): value is AbortSignal {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  try {\n    return typeof (value as AbortSignal).aborted === 'boolean';\n  } catch {\n    // AbortSignal.prototype.aborted throws if its brand check fails\n    return false;\n  }\n}\n\n/**\n * A controller object that allows you to abort an `AbortSignal` when desired.\n *\n * @remarks\n *   This interface is compatible with the `AbortController` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @internal\n */\nexport interface AbortController {\n  readonly signal: AbortSignal;\n\n  abort(reason?: any): void;\n}\n\ninterface AbortControllerConstructor {\n  new(): AbortController;\n}\n\nconst supportsAbortController = typeof (AbortController as any) === 'function';\n\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nexport function createAbortController(): AbortController | undefined {\n  if (supportsAbortController) {\n    return new (AbortController as AbortControllerConstructor)();\n  }\n  return undefined;\n}\n","import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponPromise\n} from './helpers/webidl';\nimport {\n  DequeueValue,\n  EnqueueValueWithSize,\n  PeekQueueValue,\n  type QueuePair,\n  ResetQueue\n} from './abstract-ops/queue-with-sizes';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { SimpleQueue } from './simple-queue';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { AbortSteps, ErrorSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport type {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from './writable-stream/underlying-sink';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertUnderlyingSink } from './validators/underlying-sink';\nimport { assertWritableStream } from './validators/writable-stream';\nimport { type AbortController, type AbortSignal, createAbortController } from './abort-signal';\n\ntype WritableStreamState = 'writable' | 'closed' | 'erroring' | 'errored';\n\ninterface WriteOrCloseRequest {\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n}\n\ntype WriteRequest = WriteOrCloseRequest;\ntype CloseRequest = WriteOrCloseRequest;\n\ninterface PendingAbortRequest {\n  _promise: Promise<undefined>;\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n  _reason: any;\n  _wasAlreadyErroring: boolean;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream<W = any> {\n  /** @internal */\n  _state!: WritableStreamState;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _writer: WritableStreamDefaultWriter<W> | undefined;\n  /** @internal */\n  _writableStreamController!: WritableStreamDefaultController<W>;\n  /** @internal */\n  _writeRequests!: SimpleQueue<WriteRequest>;\n  /** @internal */\n  _inFlightWriteRequest: WriteRequest | undefined;\n  /** @internal */\n  _closeRequest: CloseRequest | undefined;\n  /** @internal */\n  _inFlightCloseRequest: CloseRequest | undefined;\n  /** @internal */\n  _pendingAbortRequest: PendingAbortRequest | undefined;\n  /** @internal */\n  _backpressure!: boolean;\n\n  constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);\n  constructor(rawUnderlyingSink: UnderlyingSink<W> | null | undefined = {},\n              rawStrategy: QueuingStrategy<W> | null | undefined = {}) {\n    if (rawUnderlyingSink === undefined) {\n      rawUnderlyingSink = null;\n    } else {\n      assertObject(rawUnderlyingSink, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  /**\n   * Returns whether or not the writable stream is locked to a writer.\n   */\n  get locked(): boolean {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  /**\n   * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   * mechanism of the underlying sink.\n   *\n   * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n   * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n   * the stream) if the stream is currently locked.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  /**\n   * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   *\n   * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n   * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n   */\n  close() {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('close'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamClose(this);\n  }\n\n  /**\n   * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   * is locked, no other writer can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   */\n  getWriter(): WritableStreamDefaultWriter<W> {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nObject.defineProperties(WritableStream.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  getWriter: { enumerable: true },\n  locked: { enumerable: true }\n});\nsetFunctionName(WritableStream.prototype.abort, 'abort');\nsetFunctionName(WritableStream.prototype.close, 'close');\nsetFunctionName(WritableStream.prototype.getWriter, 'getWriter');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {\n    value: 'WritableStream',\n    configurable: true\n  });\n}\n\nexport {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight\n};\n\nexport type {\n  UnderlyingSink,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkAbortCallback\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter<W>(stream: WritableStream<W>): WritableStreamDefaultWriter<W> {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream<W>(startAlgorithm: () => void | PromiseLike<void>,\n                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                 closeAlgorithm: () => Promise<void>,\n                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                 highWaterMark = 1,\n                                 sizeAlgorithm: QueuingStrategySizeCallback<W> = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: WritableStream<W> = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller: WritableStreamDefaultController<W> = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream<W>(stream: WritableStream<W>) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined!;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = new SimpleQueue();\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x: unknown): x is WritableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return x instanceof WritableStream;\n}\n\nfunction IsWritableStreamLocked(stream: WritableStream): boolean {\n  assert(IsWritableStream(stream));\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream: WritableStream, reason: any): Promise<undefined> {\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  stream._writableStreamController._abortReason = reason;\n  stream._writableStreamController._abortController?.abort(reason);\n\n  // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n  // but it doesn't know that signaling abort runs author code that might have changed the state.\n  // Widen the type again by casting to WritableStreamState.\n  const state = stream._state as WritableStreamState;\n\n  if (state === 'closed' || state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _promise: undefined!,\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest!._promise = promise;\n\n  if (!wasAlreadyErroring) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\nfunction WritableStreamClose(stream: WritableStream<any>): Promise<undefined> {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return promiseRejectedWith(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const closeRequest: CloseRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  const writer = stream._writer;\n  if (writer !== undefined && stream._backpressure && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream: WritableStream): Promise<undefined> {\n  assert(IsWritableStreamLocked(stream));\n  assert(stream._state === 'writable');\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const writeRequest: WriteRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream: WritableStream, error: any) {\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream: WritableStream, reason: any) {\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream: WritableStream) {\n  assert(stream._state === 'erroring');\n  assert(!WritableStreamHasOperationMarkedInFlight(stream));\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  stream._writeRequests.forEach(writeRequest => {\n    writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(\n    promise,\n    () => {\n      abortRequest._resolve();\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return null;\n    },\n    (reason: any) => {\n      abortRequest._reject(reason);\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return null;\n    });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream: WritableStream): boolean {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream: WritableStream): boolean {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream: WritableStream) {\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream: WritableStream, backpressure: boolean) {\n  assert(stream._state === 'writable');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(!backpressure);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nexport class WritableStreamDefaultWriter<W = any> {\n  /** @internal */\n  _ownerWritableStream: WritableStream<W>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _closedPromiseState!: 'pending' | 'resolved' | 'rejected';\n  /** @internal */\n  _readyPromise!: Promise<undefined>;\n  /** @internal */\n  _readyPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _readyPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readyPromiseState!: 'pending' | 'fulfilled' | 'rejected';\n\n  constructor(stream: WritableStream<W>) {\n    assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n    assertWritableStream(stream, 'First parameter');\n\n    if (IsWritableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n    }\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the writers lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n   * A producer can use this information to determine the right amount of data to write.\n   *\n   * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n   * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n   * the writers lock is released.\n   */\n  get desiredSize(): number | null {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n   * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n   * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n   *\n   * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n   * rejected.\n   */\n  get ready(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n   */\n  close(): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  /**\n   * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n   * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n   * now on; otherwise, the writer will appear closed.\n   *\n   * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   * other producers from writing in an interleaved manner.\n   */\n  releaseLock(): void {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n   * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n   * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n   * errored before the writing process is initiated.\n   *\n   * Note that what \"success\" means is up to the underlying sink; it might indicate simply that the chunk has been\n   * accepted, and not necessarily that it is safely saved to its ultimate destination.\n   */\n  write(chunk: W): Promise<void>;\n  write(chunk: W = undefined!): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  releaseLock: { enumerable: true },\n  write: { enumerable: true },\n  closed: { enumerable: true },\n  desiredSize: { enumerable: true },\n  ready: { enumerable: true }\n});\nsetFunctionName(WritableStreamDefaultWriter.prototype.abort, 'abort');\nsetFunctionName(WritableStreamDefaultWriter.prototype.close, 'close');\nsetFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, 'releaseLock');\nsetFunctionName(WritableStreamDefaultWriter.prototype.write, 'write');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultWriter',\n    configurable: true\n  });\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter<W = any>(x: any): x is WritableStreamDefaultWriter<W> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultWriter;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer: WritableStreamDefaultWriter, reason: any) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamClose(stream);\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer: WritableStreamDefaultWriter): number | null {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    `Writer was released and can no longer be used to monitor the stream's closedness`);\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined!;\n}\n\nfunction WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nconst closeSentinel: unique symbol = {} as any;\n\ntype QueueRecord<W> = W | typeof closeSentinel;\n\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nexport class WritableStreamDefaultController<W = any> {\n  /** @internal */\n  _controlledWritableStream!: WritableStream<W>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<QueueRecord<W>>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _abortReason: any;\n  /** @internal */\n  _abortController: AbortController | undefined;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<W>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _writeAlgorithm!: (chunk: W) => Promise<void>;\n  /** @internal */\n  _closeAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _abortAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n   *\n   * @deprecated\n   *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n   *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n   */\n  get abortReason(): any {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('abortReason');\n    }\n    return this._abortReason;\n  }\n\n  /**\n   * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n   */\n  get signal(): AbortSignal {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('signal');\n    }\n    if (this._abortController === undefined) {\n      // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n      // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n      // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n      throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n    }\n    return this._abortController.signal;\n  }\n\n  /**\n   * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n   *\n   * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n   * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n   * normal lifecycle of interactions with the underlying sink.\n   */\n  error(e: any = undefined): void {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [AbortSteps](reason: any): Promise<void> {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n  abortReason: { enumerable: true },\n  signal: { enumerable: true },\n  error: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x: any): x is WritableStreamDefaultController<any> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultController;\n}\n\nfunction SetUpWritableStreamDefaultController<W>(stream: WritableStream<W>,\n                                                 controller: WritableStreamDefaultController<W>,\n                                                 startAlgorithm: () => void | PromiseLike<void>,\n                                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                                 closeAlgorithm: () => Promise<void>,\n                                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                                 highWaterMark: number,\n                                                 sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  assert(IsWritableStream(stream));\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._abortReason = undefined;\n  controller._abortController = createAbortController();\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = promiseResolvedWith(startResult);\n  uponPromise(\n    startPromise,\n    () => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      return null;\n    },\n    r => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n      return null;\n    }\n  );\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink<W>(stream: WritableStream<W>,\n                                                                   underlyingSink: ValidatedUnderlyingSink<W>,\n                                                                   highWaterMark: number,\n                                                                   sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let writeAlgorithm: (chunk: W) => Promise<void>;\n  let closeAlgorithm: () => Promise<void>;\n  let abortAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingSink.start !== undefined) {\n    startAlgorithm = () => underlyingSink.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingSink.write !== undefined) {\n    writeAlgorithm = chunk => underlyingSink.write!(chunk, controller);\n  } else {\n    writeAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSink.close !== undefined) {\n    closeAlgorithm = () => underlyingSink.close!();\n  } else {\n    closeAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSink.abort !== undefined) {\n    abortAlgorithm = reason => underlyingSink.abort!(reason);\n  } else {\n    abortAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpWritableStreamDefaultController(\n    stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller: WritableStreamDefaultController<any>) {\n  controller._writeAlgorithm = undefined!;\n  controller._closeAlgorithm = undefined!;\n  controller._abortAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\nfunction WritableStreamDefaultControllerClose<W>(controller: WritableStreamDefaultController<W>) {\n  EnqueueValueWithSize(controller, closeSentinel, 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize<W>(controller: WritableStreamDefaultController<W>,\n                                                        chunk: W): number {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller: WritableStreamDefaultController<any>): number {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite<W>(controller: WritableStreamDefaultController<W>,\n                                                 chunk: W,\n                                                 chunkSize: number) {\n  try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded<W>(controller: WritableStreamDefaultController<W>) {\n  const stream = controller._controlledWritableStream;\n\n  if (!controller._started) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  assert(state !== 'closed' && state !== 'errored');\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const value = PeekQueueValue(controller);\n  if (value === closeSentinel) {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, value);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller: WritableStreamDefaultController<any>, error: any) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller: WritableStreamDefaultController<any>) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(\n    sinkClosePromise,\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n      return null;\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n      return null;\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerProcessWrite<W>(controller: WritableStreamDefaultController<W>, chunk: W) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(\n    sinkWritePromise,\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n      return null;\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n      return null;\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller: WritableStreamDefaultController<any>): boolean {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller: WritableStreamDefaultController<any>, error: any) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._closedPromise = newPromise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n}\n\nfunction defaultWriterClosedPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._closedPromise_reject === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._closedPromise_resolve === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._readyPromise = newPromise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n}\n\nfunction defaultWriterReadyPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._readyPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer: WritableStreamDefaultWriter) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitialize(writer);\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._readyPromise_resolve === undefined) {\n    return;\n  }\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n","/// <reference lib=\"dom\" />\n\nfunction getGlobals(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  } else if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n","/// <reference types=\"node\" />\nimport { globals } from '../globals';\nimport { setFunctionName } from '../lib/helpers/miscellaneous';\n\ninterface DOMException extends Error {\n  name: string;\n  message: string;\n}\n\ntype DOMExceptionConstructor = new (message?: string, name?: string) => DOMException;\n\nfunction isDOMExceptionConstructor(ctor: unknown): ctor is DOMExceptionConstructor {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n    return false;\n  }\n  if ((ctor as DOMExceptionConstructor).name !== 'DOMException') {\n    return false;\n  }\n  try {\n    new (ctor as DOMExceptionConstructor)();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Support:\n * - Web browsers\n * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)\n */\nfunction getFromGlobal(): DOMExceptionConstructor | undefined {\n  const ctor = globals?.DOMException;\n  return isDOMExceptionConstructor(ctor) ? ctor : undefined;\n}\n\n/**\n * Support:\n * - All platforms\n */\nfunction createPolyfill(): DOMExceptionConstructor {\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  const ctor = function DOMException(this: DOMException, message?: string, name?: string) {\n    this.message = message || '';\n    this.name = name || 'Error';\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  } as any;\n  setFunctionName(ctor, 'DOMException');\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n  return ctor;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nconst DOMException: DOMExceptionConstructor = getFromGlobal() || createPolyfill();\n\nexport { DOMException };\n","import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\nimport { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireWritableStreamDefaultWriter,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamCloseQueuedOrInFlight,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite\n} from '../writable-stream';\nimport assert from '../../stub/assert';\nimport {\n  newPromise,\n  PerformPromiseThen,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponFulfillment,\n  uponPromise,\n  uponRejection\n} from '../helpers/webidl';\nimport { noop } from '../../utils';\nimport { type AbortSignal, isAbortSignal } from '../abort-signal';\nimport { DOMException } from '../../stub/dom-exception';\n\nexport function ReadableStreamPipeTo<T>(source: ReadableStream<T>,\n                                        dest: WritableStream<T>,\n                                        preventClose: boolean,\n                                        preventAbort: boolean,\n                                        preventCancel: boolean,\n                                        signal: AbortSignal | undefined): Promise<undefined> {\n  assert(IsReadableStream(source));\n  assert(IsWritableStream(dest));\n  assert(typeof preventClose === 'boolean');\n  assert(typeof preventAbort === 'boolean');\n  assert(typeof preventCancel === 'boolean');\n  assert(signal === undefined || isAbortSignal(signal));\n  assert(!IsReadableStreamLocked(source));\n  assert(!IsWritableStreamLocked(dest));\n\n  const reader = AcquireReadableStreamDefaultReader<T>(source);\n  const writer = AcquireWritableStreamDefaultWriter<T>(dest);\n\n  source._disturbed = true;\n\n  let shuttingDown = false;\n\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = promiseResolvedWith<void>(undefined);\n\n  return newPromise((resolve, reject) => {\n    let abortAlgorithm: () => void;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = signal.reason !== undefined ? signal.reason : new DOMException('Aborted', 'AbortError');\n        const actions: Array<() => Promise<void>> = [];\n        if (!preventAbort) {\n          actions.push(() => {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort(dest, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        if (!preventCancel) {\n          actions.push(() => {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n      };\n\n      if (signal.aborted) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    }\n\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return newPromise<void>((resolveLoop, rejectLoop) => {\n        function next(done: boolean) {\n          if (done) {\n            resolveLoop();\n          } else {\n            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n            PerformPromiseThen(pipeStep(), next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep(): Promise<boolean> {\n      if (shuttingDown) {\n        return promiseResolvedWith(true);\n      }\n\n      return PerformPromiseThen(writer._readyPromise, () => {\n        return newPromise<boolean>((resolveRead, rejectRead) => {\n          ReadableStreamDefaultReaderRead(\n            reader,\n            {\n              _chunkSteps: chunk => {\n                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                resolveRead(false);\n              },\n              _closeSteps: () => resolveRead(true),\n              _errorSteps: rejectRead\n            }\n          );\n        });\n      });\n    }\n\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, storedError => {\n      if (!preventAbort) {\n        shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n      return null;\n    });\n\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n      return null;\n    });\n\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (!preventClose) {\n        shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n      } else {\n        shutdown();\n      }\n      return null;\n    });\n\n    // Closing must be propagated backward\n    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n      const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    setPromiseIsHandledToTrue(pipeLoop());\n\n    function waitForWritesToFinish(): Promise<void> {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return PerformPromiseThen(\n        currentWrite,\n        () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined\n      );\n    }\n\n    function isOrBecomesErrored(stream: ReadableStream | WritableStream,\n                                promise: Promise<void>,\n                                action: (reason: any) => null) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        uponRejection(promise, action);\n      }\n    }\n\n    function isOrBecomesClosed(stream: ReadableStream | WritableStream, promise: Promise<void>, action: () => null) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        uponFulfillment(promise, action);\n      }\n    }\n\n    function shutdownWithAction(action: () => Promise<unknown>, originalIsError?: boolean, originalError?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest(): null {\n        uponPromise(\n          action(),\n          () => finalize(originalIsError, originalError),\n          newError => finalize(true, newError)\n        );\n        return null;\n      }\n    }\n\n    function shutdown(isError?: boolean, error?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError?: boolean, error?: any): null {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n\n      return null;\n    }\n  });\n}\n","import type { QueuingStrategySizeCallback } from '../queuing-strategy';\nimport assert from '../../stub/assert';\nimport { DequeueValue, EnqueueValueWithSize, type QueuePair, ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  type ReadRequest\n} from './default-reader';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\nimport type { ValidatedUnderlyingSource } from './underlying-source';\nimport { setFunctionName, typeIsObject } from '../helpers/miscellaneous';\nimport { CancelSteps, PullSteps, ReleaseSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableStreamDefaultController<R> {\n  /** @internal */\n  _controlledReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<R>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<R>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the controlled readable stream.\n   */\n  enqueue(chunk: R): void;\n  enqueue(chunk: R = undefined!): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<R>): void {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      readRequest._chunkSteps(chunk);\n    } else {\n      ReadableStreamAddReadRequest(stream, readRequest);\n      ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n  }\n\n  /** @internal */\n  [ReleaseSteps](): void {\n    // Do nothing.\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(ReadableStreamDefaultController.prototype.close, 'close');\nsetFunctionName(ReadableStreamDefaultController.prototype.enqueue, 'enqueue');\nsetFunctionName(ReadableStreamDefaultController.prototype.error, 'error');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController<R = any>(x: any): x is ReadableStreamDefaultController<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultController;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller: ReadableStreamDefaultController<any>): void {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n\n      return null;\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n      return null;\n    }\n  );\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller: ReadableStreamDefaultController<any>): boolean {\n  const stream = controller._controlledReadableStream;\n\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller: ReadableStreamDefaultController<any>) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nexport function ReadableStreamDefaultControllerClose(controller: ReadableStreamDefaultController<any>) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nexport function ReadableStreamDefaultControllerEnqueue<R>(\n  controller: ReadableStreamDefaultController<R>,\n  chunk: R\n): void {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableStreamDefaultControllerError(controller: ReadableStreamDefaultController<any>, e: any) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableStreamDefaultControllerGetDesiredSize(\n  controller: ReadableStreamDefaultController<any>\n): number | null {\n  const state = controller._controlledReadableStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nexport function ReadableStreamDefaultControllerHasBackpressure(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function ReadableStreamDefaultControllerCanCloseOrEnqueue(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  const state = controller._controlledReadableStream._state;\n\n  if (!controller._closeRequested && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function SetUpReadableStreamDefaultController<R>(stream: ReadableStream<R>,\n                                                        controller: ReadableStreamDefaultController<R>,\n                                                        startAlgorithm: () => void | PromiseLike<void>,\n                                                        pullAlgorithm: () => Promise<void>,\n                                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                                        highWaterMark: number,\n                                                        sizeAlgorithm: QueuingStrategySizeCallback<R>) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      return null;\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n      return null;\n    }\n  );\n}\n\nexport function SetUpReadableStreamDefaultControllerFromUnderlyingSource<R>(\n  stream: ReadableStream<R>,\n  underlyingSource: ValidatedUnderlyingSource<R>,\n  highWaterMark: number,\n  sizeAlgorithm: QueuingStrategySizeCallback<R>\n) {\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void>;\n  let pullAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (underlyingSource.start !== undefined) {\n    startAlgorithm = () => underlyingSource.start!(controller);\n  } else {\n    startAlgorithm = () => undefined;\n  }\n  if (underlyingSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingSource.pull!(controller);\n  } else {\n    pullAlgorithm = () => promiseResolvedWith(undefined);\n  }\n  if (underlyingSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingSource.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n","import {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  type DefaultReadableStream,\n  IsReadableStream,\n  type ReadableByteStream,\n  ReadableStream,\n  ReadableStreamCancel,\n  type ReadableStreamReader\n} from '../readable-stream';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  type ReadRequest\n} from './default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderRead,\n  type ReadIntoRequest\n} from './byob-reader';\nimport assert from '../../stub/assert';\nimport { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\nimport {\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError\n} from './default-controller';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamControllerClose,\n  ReadableByteStreamControllerEnqueue,\n  ReadableByteStreamControllerError,\n  ReadableByteStreamControllerGetBYOBRequest,\n  ReadableByteStreamControllerRespond,\n  ReadableByteStreamControllerRespondWithNewView\n} from './byte-stream-controller';\nimport { CreateArrayFromList } from '../abstract-ops/ecmascript';\nimport { CloneAsUint8Array } from '../abstract-ops/miscellaneous';\nimport type { NonShared } from '../helpers/array-buffer-view';\n\nexport function ReadableStreamTee<R>(stream: ReadableStream<R>,\n                                     cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n  if (IsReadableByteStreamController(stream._readableStreamController)) {\n    return ReadableByteStreamTee(stream as unknown as ReadableByteStream) as\n      unknown as [ReadableStream<R>, ReadableStream<R>];\n  }\n  return ReadableStreamDefaultTee(stream, cloneForBranch2);\n}\n\nexport function ReadableStreamDefaultTee<R>(\n  stream: ReadableStream<R>,\n  cloneForBranch2: boolean\n): [DefaultReadableStream<R>, DefaultReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n\n  let reading = false;\n  let readAgain = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: DefaultReadableStream<R>;\n  let branch2: DefaultReadableStream<R>;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<undefined>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm(): Promise<void> {\n    if (reading) {\n      readAgain = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgain = false;\n          const chunk1 = chunk;\n          const chunk2 = chunk;\n\n          // There is no way to access the cloning code right now in the reference implementation.\n          // If we add one then we'll need an implementation for serializable objects.\n          // if (!canceled2 && cloneForBranch2) {\n          //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n          // }\n\n          if (!canceled1) {\n            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgain) {\n            pullAlgorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n        }\n\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {\n    // do nothing\n  }\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  uponRejection(reader._closedPromise, (r: any) => {\n    ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n    if (!canceled1 || !canceled2) {\n      resolveCancelPromise(undefined);\n    }\n    return null;\n  });\n\n  return [branch1, branch2];\n}\n\nexport function ReadableByteStreamTee(stream: ReadableByteStream): [ReadableByteStream, ReadableByteStream] {\n  assert(IsReadableStream(stream));\n  assert(IsReadableByteStreamController(stream._readableStreamController));\n\n  let reader: ReadableStreamReader<NonShared<Uint8Array>> = AcquireReadableStreamDefaultReader(stream);\n  let reading = false;\n  let readAgainForBranch1 = false;\n  let readAgainForBranch2 = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableByteStream;\n  let branch2: ReadableByteStream;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<void>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function forwardReaderError(thisReader: ReadableStreamReader<NonShared<Uint8Array>>) {\n    uponRejection(thisReader._closedPromise, r => {\n      if (thisReader !== reader) {\n        return null;\n      }\n      ReadableByteStreamControllerError(branch1._readableStreamController, r);\n      ReadableByteStreamControllerError(branch2._readableStreamController, r);\n      if (!canceled1 || !canceled2) {\n        resolveCancelPromise(undefined);\n      }\n      return null;\n    });\n  }\n\n  function pullWithDefaultReader() {\n    if (IsReadableStreamBYOBReader(reader)) {\n      assert(reader._readIntoRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamDefaultReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const readRequest: ReadRequest<NonShared<Uint8Array>> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const chunk1 = chunk;\n          let chunk2 = chunk;\n          if (!canceled1 && !canceled2) {\n            try {\n              chunk2 = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n          }\n\n          if (!canceled1) {\n            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableByteStreamControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableByteStreamControllerClose(branch2._readableStreamController);\n        }\n        if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n        }\n        if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n        }\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n  }\n\n  function pullWithBYOBReader(view: NonShared<ArrayBufferView>, forBranch2: boolean) {\n    if (IsReadableStreamDefaultReader<NonShared<Uint8Array>>(reader)) {\n      assert(reader._readRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamBYOBReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const byobBranch = forBranch2 ? branch2 : branch1;\n    const otherBranch = forBranch2 ? branch1 : branch2;\n\n    const readIntoRequest: ReadIntoRequest<NonShared<ArrayBufferView>> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          readAgainForBranch1 = false;\n          readAgainForBranch2 = false;\n\n          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n          if (!otherCanceled) {\n            let clonedChunk;\n            try {\n              clonedChunk = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n            if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n          } else if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n\n          reading = false;\n          if (readAgainForBranch1) {\n            pull1Algorithm();\n          } else if (readAgainForBranch2) {\n            pull2Algorithm();\n          }\n        });\n      },\n      _closeSteps: chunk => {\n        reading = false;\n\n        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n        if (!byobCanceled) {\n          ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n        }\n        if (!otherCanceled) {\n          ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n        }\n\n        if (chunk !== undefined) {\n          assert(chunk.byteLength === 0);\n\n          if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n          }\n        }\n\n        if (!byobCanceled || !otherCanceled) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n  }\n\n  function pull1Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch1 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, false);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function pull2Algorithm(): Promise<void> {\n    if (reading) {\n      readAgainForBranch2 = true;\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, true);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm(): void {\n    return;\n  }\n\n  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n\n  forwardReaderError(reader);\n\n  return [branch1, branch2];\n}\n","import { typeIsObject } from '../helpers/miscellaneous';\nimport type { ReadableStreamDefaultReadResult } from './default-reader';\n\n/**\n * A common interface for a `ReadadableStream` implementation.\n *\n * @public\n */\nexport interface ReadableStreamLike<R = any> {\n  readonly locked: boolean;\n\n  getReader(): ReadableStreamDefaultReaderLike<R>;\n}\n\n/**\n * A common interface for a `ReadableStreamDefaultReader` implementation.\n *\n * @public\n */\nexport interface ReadableStreamDefaultReaderLike<R = any> {\n  readonly closed: Promise<undefined>;\n\n  cancel(reason?: any): Promise<void>;\n\n  read(): Promise<ReadableStreamDefaultReadResult<R>>;\n\n  releaseLock(): void;\n}\n\nexport function isReadableStreamLike<R>(stream: unknown): stream is ReadableStreamLike<R> {\n  return typeIsObject(stream) && typeof (stream as ReadableStreamLike<R>).getReader !== 'undefined';\n}\n","import { CreateReadableStream, type DefaultReadableStream } from '../readable-stream';\nimport {\n  isReadableStreamLike,\n  type ReadableStreamDefaultReaderLike,\n  type ReadableStreamLike\n} from './readable-stream-like';\nimport { ReadableStreamDefaultControllerClose, ReadableStreamDefaultControllerEnqueue } from './default-controller';\nimport { GetIterator, GetMethod, IteratorComplete, IteratorNext, IteratorValue } from '../abstract-ops/ecmascript';\nimport { promiseRejectedWith, promiseResolvedWith, reflectCall, transformPromiseWith } from '../helpers/webidl';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { noop } from '../../utils';\n\nexport function ReadableStreamFrom<R>(\n  source: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>\n): DefaultReadableStream<R> {\n  if (isReadableStreamLike(source)) {\n    return ReadableStreamFromDefaultReader(source.getReader());\n  }\n  return ReadableStreamFromIterable(source);\n}\n\nexport function ReadableStreamFromIterable<R>(asyncIterable: Iterable<R> | AsyncIterable<R>): DefaultReadableStream<R> {\n  let stream: DefaultReadableStream<R>;\n  const iteratorRecord = GetIterator(asyncIterable, 'async');\n\n  const startAlgorithm = noop;\n\n  function pullAlgorithm(): Promise<void> {\n    let nextResult;\n    try {\n      nextResult = IteratorNext(iteratorRecord);\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const nextPromise = promiseResolvedWith(nextResult);\n    return transformPromiseWith(nextPromise, iterResult => {\n      if (!typeIsObject(iterResult)) {\n        throw new TypeError('The promise returned by the iterator.next() method must fulfill with an object');\n      }\n      const done = IteratorComplete(iterResult);\n      if (done) {\n        ReadableStreamDefaultControllerClose(stream._readableStreamController);\n      } else {\n        const value = IteratorValue(iterResult);\n        ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n      }\n    });\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    const iterator = iteratorRecord.iterator;\n    let returnMethod: (typeof iterator)['return'] | undefined;\n    try {\n      returnMethod = GetMethod(iterator, 'return');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    if (returnMethod === undefined) {\n      return promiseResolvedWith(undefined);\n    }\n    let returnResult: IteratorResult<R> | Promise<IteratorResult<R>>;\n    try {\n      returnResult = reflectCall(returnMethod, iterator, [reason]);\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    const returnPromise = promiseResolvedWith(returnResult);\n    return transformPromiseWith(returnPromise, iterResult => {\n      if (!typeIsObject(iterResult)) {\n        throw new TypeError('The promise returned by the iterator.return() method must fulfill with an object');\n      }\n      return undefined;\n    });\n  }\n\n  stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n  return stream;\n}\n\nexport function ReadableStreamFromDefaultReader<R>(\n  reader: ReadableStreamDefaultReaderLike<R>\n): DefaultReadableStream<R> {\n  let stream: DefaultReadableStream<R>;\n\n  const startAlgorithm = noop;\n\n  function pullAlgorithm(): Promise<void> {\n    let readPromise;\n    try {\n      readPromise = reader.read();\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n    return transformPromiseWith(readPromise, readResult => {\n      if (!typeIsObject(readResult)) {\n        throw new TypeError('The promise returned by the reader.read() method must fulfill with an object');\n      }\n      if (readResult.done) {\n        ReadableStreamDefaultControllerClose(stream._readableStreamController);\n      } else {\n        const value = readResult.value;\n        ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n      }\n    });\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    try {\n      return promiseResolvedWith(reader.cancel(reason));\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n  }\n\n  stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n  return stream;\n}\n","import { assertDictionary, assertFunction, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport type {\n  ReadableStreamController,\n  UnderlyingByteSource,\n  UnderlyingDefaultOrByteSource,\n  UnderlyingDefaultOrByteSourcePullCallback,\n  UnderlyingDefaultOrByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  ValidatedUnderlyingDefaultOrByteSource\n} from '../readable-stream/underlying-source';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\n\nexport function convertUnderlyingDefaultOrByteSource<R>(\n  source: UnderlyingSource<R> | UnderlyingByteSource | null,\n  context: string\n): ValidatedUnderlyingDefaultOrByteSource<R> {\n  assertDictionary(source, context);\n  const original = source as (UnderlyingDefaultOrByteSource<R> | null);\n  const autoAllocateChunkSize = original?.autoAllocateChunkSize;\n  const cancel = original?.cancel;\n  const pull = original?.pull;\n  const start = original?.start;\n  const type = original?.type;\n  return {\n    autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n      undefined :\n      convertUnsignedLongLongWithEnforceRange(\n        autoAllocateChunkSize,\n        `${context} has member 'autoAllocateChunkSize' that`\n      ),\n    cancel: cancel === undefined ?\n      undefined :\n      convertUnderlyingSourceCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    pull: pull === undefined ?\n      undefined :\n      convertUnderlyingSourcePullCallback(pull, original!, `${context} has member 'pull' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSourceStartCallback(start, original!, `${context} has member 'start' that`),\n    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n  };\n}\n\nfunction convertUnderlyingSourceCancelCallback(\n  fn: UnderlyingSourceCancelCallback,\n  original: UnderlyingDefaultOrByteSource,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSourcePullCallback<R>(\n  fn: UnderlyingDefaultOrByteSourcePullCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): (controller: ReadableStreamController<R>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSourceStartCallback<R>(\n  fn: UnderlyingDefaultOrByteSourceStartCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): UnderlyingDefaultOrByteSourceStartCallback<R> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertReadableStreamType(type: string, context: string): 'bytes' {\n  type = `${type}`;\n  if (type !== 'bytes') {\n    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n  }\n  return type;\n}\n","import { assertDictionary } from './basic';\nimport type {\n  ReadableStreamIteratorOptions,\n  ValidatedReadableStreamIteratorOptions\n} from '../readable-stream/iterator-options';\n\nexport function convertIteratorOptions(options: ReadableStreamIteratorOptions | null | undefined,\n                                       context: string): ValidatedReadableStreamIteratorOptions {\n  assertDictionary(options, context);\n  const preventCancel = options?.preventCancel;\n  return { preventCancel: Boolean(preventCancel) };\n}\n","import { assertDictionary } from './basic';\nimport type { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\nimport { type AbortSignal, isAbortSignal } from '../abort-signal';\n\nexport function convertPipeOptions(options: StreamPipeOptions | null | undefined,\n                                   context: string): ValidatedStreamPipeOptions {\n  assertDictionary(options, context);\n  const preventAbort = options?.preventAbort;\n  const preventCancel = options?.preventCancel;\n  const preventClose = options?.preventClose;\n  const signal = options?.signal;\n  if (signal !== undefined) {\n    assertAbortSignal(signal, `${context} has member 'signal' that`);\n  }\n  return {\n    preventAbort: Boolean(preventAbort),\n    preventCancel: Boolean(preventCancel),\n    preventClose: Boolean(preventClose),\n    signal\n  };\n}\n\nfunction assertAbortSignal(signal: unknown, context: string): asserts signal is AbortSignal {\n  if (!isAbortSignal(signal)) {\n    throw new TypeError(`${context} is not an AbortSignal.`);\n  }\n}\n","import { assertDictionary, assertRequiredField } from './basic';\nimport { ReadableStream } from '../readable-stream';\nimport { WritableStream } from '../writable-stream';\nimport { assertReadableStream } from './readable-stream';\nimport { assertWritableStream } from './writable-stream';\n\nexport function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(\n  pair: { readable: RS; writable: WS } | null | undefined,\n  context: string\n): { readable: RS; writable: WS } {\n  assertDictionary(pair, context);\n\n  const readable = pair?.readable;\n  assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n  assertReadableStream(readable, `${context} has member 'readable' that`);\n\n  const writable = pair?.writable;\n  assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n  assertWritableStream(writable, `${context} has member 'writable' that`);\n\n  return { readable, writable };\n}\n","import assert from '../stub/assert';\nimport {\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith\n} from './helpers/webidl';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { AcquireReadableStreamAsyncIterator, type ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\nimport { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderErrorReadRequests,\n  type ReadableStreamDefaultReadResult\n} from './readable-stream/default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderErrorReadIntoRequests,\n  type ReadableStreamBYOBReadResult\n} from './readable-stream/byob-reader';\nimport { ReadableStreamPipeTo } from './readable-stream/pipe';\nimport { ReadableStreamTee } from './readable-stream/tee';\nimport { ReadableStreamFrom } from './readable-stream/from';\nimport { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\nimport { SimpleQueue } from './simple-queue';\nimport {\n  ReadableByteStreamController,\n  ReadableStreamBYOBRequest,\n  SetUpReadableByteStreamController,\n  SetUpReadableByteStreamControllerFromUnderlyingSource\n} from './readable-stream/byte-stream-controller';\nimport {\n  ReadableStreamDefaultController,\n  SetUpReadableStreamDefaultController,\n  SetUpReadableStreamDefaultControllerFromUnderlyingSource\n} from './readable-stream/default-controller';\nimport type {\n  UnderlyingByteSource,\n  UnderlyingByteSourcePullCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceStartCallback\n} from './readable-stream/underlying-source';\nimport { noop } from '../utils';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { CreateArrayFromList, SymbolAsyncIterator } from './abstract-ops/ecmascript';\nimport { CancelSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertUnderlyingDefaultOrByteSource } from './validators/underlying-source';\nimport type {\n  ReadableStreamBYOBReaderReadOptions,\n  ReadableStreamGetReaderOptions\n} from './readable-stream/reader-options';\nimport { convertReaderOptions } from './validators/reader-options';\nimport type { StreamPipeOptions, ValidatedStreamPipeOptions } from './readable-stream/pipe-options';\nimport type { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\nimport { convertIteratorOptions } from './validators/iterator-options';\nimport { convertPipeOptions } from './validators/pipe-options';\nimport type { ReadableWritablePair } from './readable-stream/readable-writable-pair';\nimport { convertReadableWritablePair } from './validators/readable-writable-pair';\nimport type { ReadableStreamDefaultReaderLike, ReadableStreamLike } from './readable-stream/readable-stream-like';\nimport type { NonShared } from './helpers/array-buffer-view';\n\nexport type DefaultReadableStream<R = any> = ReadableStream<R> & {\n  _readableStreamController: ReadableStreamDefaultController<R>\n};\n\nexport type ReadableByteStream = ReadableStream<NonShared<Uint8Array>> & {\n  _readableStreamController: ReadableByteStreamController\n};\n\ntype ReadableStreamState = 'readable' | 'closed' | 'errored';\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nexport class ReadableStream<R = any> implements AsyncIterable<R> {\n  /** @internal */\n  _state!: ReadableStreamState;\n  /** @internal */\n  _reader: ReadableStreamReader<R> | undefined;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _disturbed!: boolean;\n  /** @internal */\n  _readableStreamController!: ReadableStreamDefaultController<R> | ReadableByteStreamController;\n\n  constructor(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number; size?: undefined });\n  constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);\n  constructor(rawUnderlyingSource: UnderlyingSource<R> | UnderlyingByteSource | null | undefined = {},\n              rawStrategy: QueuingStrategy<R> | null | undefined = {}) {\n    if (rawUnderlyingSource === undefined) {\n      rawUnderlyingSource = null;\n    } else {\n      assertObject(rawUnderlyingSource, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n\n    InitializeReadableStream(this);\n\n    if (underlyingSource.type === 'bytes') {\n      if (strategy.size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n      const highWaterMark = ExtractHighWaterMark(strategy, 0);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(\n        this as unknown as ReadableByteStream,\n        underlyingSource,\n        highWaterMark\n      );\n    } else {\n      assert(underlyingSource.type === undefined);\n      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n      const highWaterMark = ExtractHighWaterMark(strategy, 1);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark,\n        sizeAlgorithm\n      );\n    }\n  }\n\n  /**\n   * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   */\n  get locked(): boolean {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  /**\n   * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n   *\n   * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n   * method, which might or might not use it.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  /**\n   * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n   *\n   * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n   * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   * control over allocation.\n   */\n  getReader({ mode }: { mode: 'byob' }): ReadableStreamBYOBReader;\n  /**\n   * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n   * While the stream is locked, no other reader can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n   * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n   * or cancel the stream, which would interfere with your abstraction.\n   */\n  getReader(): ReadableStreamDefaultReader<R>;\n  getReader(\n    rawOptions: ReadableStreamGetReaderOptions | null | undefined = undefined\n  ): ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    const options = convertReaderOptions(rawOptions, 'First parameter');\n\n    if (options.mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    assert(options.mode === 'byob');\n    return AcquireReadableStreamBYOBReader(this as unknown as ReadableByteStream);\n  }\n\n  /**\n   * Provides a convenient, chainable way of piping this readable stream through a transform stream\n   * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n   * into the writable side of the supplied pair, and returns the readable side for further use.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeThrough<RS extends ReadableStream>(\n    transform: { readable: RS; writable: WritableStream<R> },\n    options?: StreamPipeOptions\n  ): RS;\n  pipeThrough<RS extends ReadableStream>(\n    rawTransform: { readable: RS; writable: WritableStream<R> } | null | undefined,\n    rawOptions: StreamPipeOptions | null | undefined = {}\n  ): RS {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('pipeThrough');\n    }\n    assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n\n    const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n    const options = convertPipeOptions(rawOptions, 'Second parameter');\n\n    if (IsReadableStreamLocked(this)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n    if (IsWritableStreamLocked(transform.writable)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    const promise = ReadableStreamPipeTo(\n      this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n\n    setPromiseIsHandledToTrue(promise);\n\n    return transform.readable;\n  }\n\n  /**\n   * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n   * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n   * when the piping process completes successfully, or rejects if any errors were encountered.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n  pipeTo(destination: WritableStream<R> | null | undefined,\n         rawOptions: StreamPipeOptions | null | undefined = {}): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('pipeTo'));\n    }\n\n    if (destination === undefined) {\n      return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n    }\n    if (!IsWritableStream(destination)) {\n      return promiseRejectedWith(\n        new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`)\n      );\n    }\n\n    let options: ValidatedStreamPipeOptions;\n    try {\n      options = convertPipeOptions(rawOptions, 'Second parameter');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream')\n      );\n    }\n    if (IsWritableStreamLocked(destination)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream')\n      );\n    }\n\n    return ReadableStreamPipeTo<R>(\n      this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n  }\n\n  /**\n   * Tees this readable stream, returning a two-element array containing the two resulting branches as\n   * new {@link ReadableStream} instances.\n   *\n   * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n   * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n   * propagated to the stream's underlying source.\n   *\n   * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n   * this could allow interference between the two branches.\n   */\n  tee(): [ReadableStream<R>, ReadableStream<R>] {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return CreateArrayFromList(branches);\n  }\n\n  /**\n   * Asynchronously iterates over the chunks in the stream's internal queue.\n   *\n   * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n   * is called, e.g. by breaking out of the loop.\n   *\n   * By default, calling the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method will also\n   * cancel the stream. To prevent this, use the stream's {@link ReadableStream.values | values()} method, passing\n   * `true` for the `preventCancel` option.\n   */\n  values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n  values(rawOptions: ReadableStreamIteratorOptions | null | undefined = undefined): ReadableStreamAsyncIterator<R> {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('values');\n    }\n\n    const options = convertIteratorOptions(rawOptions, 'First parameter');\n    return AcquireReadableStreamAsyncIterator<R>(this, options.preventCancel);\n  }\n\n  /**\n   * {@inheritDoc ReadableStream.values}\n   */\n  [Symbol.asyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n\n  [SymbolAsyncIterator](options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R> {\n    // Stub implementation, overridden below\n    return this.values(options);\n  }\n\n  /**\n   * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n   *\n   * This can be used to adapt various kinds of objects into a readable stream,\n   * such as an array, an async generator, or a Node.js readable stream.\n   */\n  static from<R>(asyncIterable: Iterable<R> | AsyncIterable<R> | ReadableStreamLike<R>): ReadableStream<R> {\n    return ReadableStreamFrom(asyncIterable);\n  }\n}\n\nObject.defineProperties(ReadableStream, {\n  from: { enumerable: true }\n});\nObject.defineProperties(ReadableStream.prototype, {\n  cancel: { enumerable: true },\n  getReader: { enumerable: true },\n  pipeThrough: { enumerable: true },\n  pipeTo: { enumerable: true },\n  tee: { enumerable: true },\n  values: { enumerable: true },\n  locked: { enumerable: true }\n});\nsetFunctionName(ReadableStream.from, 'from');\nsetFunctionName(ReadableStream.prototype.cancel, 'cancel');\nsetFunctionName(ReadableStream.prototype.getReader, 'getReader');\nsetFunctionName(ReadableStream.prototype.pipeThrough, 'pipeThrough');\nsetFunctionName(ReadableStream.prototype.pipeTo, 'pipeTo');\nsetFunctionName(ReadableStream.prototype.tee, 'tee');\nsetFunctionName(ReadableStream.prototype.values, 'values');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {\n    value: 'ReadableStream',\n    configurable: true\n  });\n}\nObject.defineProperty(ReadableStream.prototype, SymbolAsyncIterator, {\n  value: ReadableStream.prototype.values,\n  writable: true,\n  configurable: true\n});\n\nexport type {\n  ReadableStreamAsyncIterator,\n  ReadableStreamDefaultReadResult,\n  ReadableStreamBYOBReadResult,\n  ReadableStreamBYOBReaderReadOptions,\n  UnderlyingByteSource,\n  UnderlyingSource,\n  UnderlyingSourceStartCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceCancelCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingByteSourcePullCallback,\n  StreamPipeOptions,\n  ReadableWritablePair,\n  ReadableStreamIteratorOptions,\n  ReadableStreamLike,\n  ReadableStreamDefaultReaderLike\n};\n\n// Abstract operations for the ReadableStream.\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableStream<R>(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>,\n  highWaterMark = 1,\n  sizeAlgorithm: QueuingStrategySizeCallback<R> = () => 1\n): DefaultReadableStream<R> {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: DefaultReadableStream<R> = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableByteStream(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>\n): ReadableByteStream {\n  const stream: ReadableByteStream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream: ReadableStream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nexport function IsReadableStream(x: unknown): x is ReadableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStream;\n}\n\nexport function IsReadableStreamDisturbed(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  return stream._disturbed;\n}\n\nexport function IsReadableStreamLocked(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamCancel<R>(stream: ReadableStream<R>, reason: any): Promise<undefined> {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const reader = stream._reader;\n  if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n    const readIntoRequests = reader._readIntoRequests;\n    reader._readIntoRequests = new SimpleQueue();\n    readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._closeSteps(undefined);\n    });\n  }\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n}\n\nexport function ReadableStreamClose<R>(stream: ReadableStream<R>): void {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    const readRequests = reader._readRequests;\n    reader._readRequests = new SimpleQueue();\n    readRequests.forEach(readRequest => {\n      readRequest._closeSteps();\n    });\n  }\n}\n\nexport function ReadableStreamError<R>(stream: ReadableStream<R>, e: any): void {\n  assert(IsReadableStream(stream));\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n    ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n  }\n}\n\n// Readers\n\nexport type ReadableStreamReader<R> = ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader;\n\nexport {\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader\n};\n\n// Controllers\n\nexport {\n  ReadableStreamDefaultController,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController\n};\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n","import type { QueuingStrategyInit } from '../queuing-strategy';\nimport { assertDictionary, assertRequiredField, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategyInit(init: QueuingStrategyInit | null | undefined,\n                                           context: string): QueuingStrategyInit {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n  return {\n    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n  };\n}\n","import type { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk: ArrayBufferView): number => {\n  return chunk.byteLength;\n};\nsetFunctionName(byteLengthSizeFunction, 'size');\n\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nexport default class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {\n  /** @internal */\n  readonly _byteLengthQueuingStrategyHighWaterMark: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('highWaterMark');\n    }\n    return this._byteLengthQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by returning the value of its `byteLength` property.\n   */\n  get size(): (chunk: ArrayBufferView) => number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('size');\n    }\n    return byteLengthSizeFunction;\n  }\n}\n\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'ByteLengthQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the ByteLengthQueuingStrategy.\n\nfunction byteLengthBrandCheckException(name: string): TypeError {\n  return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\n\nexport function IsByteLengthQueuingStrategy(x: any): x is ByteLengthQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof ByteLengthQueuingStrategy;\n}\n","import type { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = (): 1 => {\n  return 1;\n};\nsetFunctionName(countSizeFunction, 'size');\n\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nexport default class CountQueuingStrategy implements QueuingStrategy<any> {\n  /** @internal */\n  readonly _countQueuingStrategyHighWaterMark!: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('highWaterMark');\n    }\n    return this._countQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by always returning 1.\n   * This ensures that the total queue size is a count of the number of chunks in the queue.\n   */\n  get size(): (chunk: any) => 1 {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('size');\n    }\n    return countSizeFunction;\n  }\n}\n\nObject.defineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'CountQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the CountQueuingStrategy.\n\nfunction countBrandCheckException(name: string): TypeError {\n  return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\n\nexport function IsCountQueuingStrategy(x: any): x is CountQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof CountQueuingStrategy;\n}\n","import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from '../transform-stream/transformer';\nimport { TransformStreamDefaultController } from '../transform-stream';\n\nexport function convertTransformer<I, O>(original: Transformer<I, O> | null,\n                                         context: string): ValidatedTransformer<I, O> {\n  assertDictionary(original, context);\n  const cancel = original?.cancel;\n  const flush = original?.flush;\n  const readableType = original?.readableType;\n  const start = original?.start;\n  const transform = original?.transform;\n  const writableType = original?.writableType;\n  return {\n    cancel: cancel === undefined ?\n      undefined :\n      convertTransformerCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    flush: flush === undefined ?\n      undefined :\n      convertTransformerFlushCallback(flush, original!, `${context} has member 'flush' that`),\n    readableType,\n    start: start === undefined ?\n      undefined :\n      convertTransformerStartCallback(start, original!, `${context} has member 'start' that`),\n    transform: transform === undefined ?\n      undefined :\n      convertTransformerTransformCallback(transform, original!, `${context} has member 'transform' that`),\n    writableType\n  };\n}\n\nfunction convertTransformerFlushCallback<I, O>(\n  fn: TransformerFlushCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): (controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertTransformerStartCallback<I, O>(\n  fn: TransformerStartCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): TransformerStartCallback<O> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertTransformerTransformCallback<I, O>(\n  fn: TransformerTransformCallback<I, O>,\n  original: Transformer<I, O>,\n  context: string\n): (chunk: I, controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: I, controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction convertTransformerCancelCallback<I, O>(\n  fn: TransformerCancelCallback,\n  original: Transformer<I, O>,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n","import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith,\n  uponPromise\n} from './helpers/webidl';\nimport { CreateReadableStream, type DefaultReadableStream, ReadableStream } from './readable-stream';\nimport {\n  ReadableStreamDefaultControllerCanCloseOrEnqueue,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure\n} from './readable-stream/default-controller';\nimport type { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\nimport { setFunctionName, typeIsObject } from './helpers/miscellaneous';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from './transform-stream/transformer';\nimport { convertTransformer } from './validators/transformer';\n\n// Class TransformStream\n\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nexport class TransformStream<I = any, O = any> {\n  /** @internal */\n  _writable!: WritableStream<I>;\n  /** @internal */\n  _readable!: DefaultReadableStream<O>;\n  /** @internal */\n  _backpressure!: boolean;\n  /** @internal */\n  _backpressureChangePromise!: Promise<void>;\n  /** @internal */\n  _backpressureChangePromise_resolve!: () => void;\n  /** @internal */\n  _transformStreamController!: TransformStreamDefaultController<O>;\n\n  constructor(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>\n  );\n  constructor(rawTransformer: Transformer<I, O> | null | undefined = {},\n              rawWritableStrategy: QueuingStrategy<I> | null | undefined = {},\n              rawReadableStrategy: QueuingStrategy<O> | null | undefined = {}) {\n    if (rawTransformer === undefined) {\n      rawTransformer = null;\n    }\n\n    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n\n    const transformer = convertTransformer(rawTransformer, 'First parameter');\n    if (transformer.readableType !== undefined) {\n      throw new RangeError('Invalid readableType specified');\n    }\n    if (transformer.writableType !== undefined) {\n      throw new RangeError('Invalid writableType specified');\n    }\n\n    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n\n    let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n    const startPromise = newPromise<void>(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(\n      this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm\n    );\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    if (transformer.start !== undefined) {\n      startPromise_resolve(transformer.start(this._transformStreamController));\n    } else {\n      startPromise_resolve(undefined);\n    }\n  }\n\n  /**\n   * The readable side of the transform stream.\n   */\n  get readable(): ReadableStream<O> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  /**\n   * The writable side of the transform stream.\n   */\n  get writable(): WritableStream<I> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\nObject.defineProperties(TransformStream.prototype, {\n  readable: { enumerable: true },\n  writable: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {\n    value: 'TransformStream',\n    configurable: true\n  });\n}\n\nexport type {\n  Transformer,\n  TransformerCancelCallback,\n  TransformerStartCallback,\n  TransformerFlushCallback,\n  TransformerTransformCallback\n};\n\n// Transform Stream Abstract Operations\n\nexport function CreateTransformStream<I, O>(startAlgorithm: () => void | PromiseLike<void>,\n                                            transformAlgorithm: (chunk: I) => Promise<void>,\n                                            flushAlgorithm: () => Promise<void>,\n                                            cancelAlgorithm: (reason: any) => Promise<void>,\n                                            writableHighWaterMark = 1,\n                                            writableSizeAlgorithm: QueuingStrategySizeCallback<I> = () => 1,\n                                            readableHighWaterMark = 0,\n                                            readableSizeAlgorithm: QueuingStrategySizeCallback<O> = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream: TransformStream<I, O> = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n  const startPromise = newPromise<void>(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream<I, O>(stream: TransformStream<I, O>,\n                                         startPromise: Promise<void>,\n                                         writableHighWaterMark: number,\n                                         writableSizeAlgorithm: QueuingStrategySizeCallback<I>,\n                                         readableHighWaterMark: number,\n                                         readableSizeAlgorithm: QueuingStrategySizeCallback<O>) {\n  function startAlgorithm(): Promise<void> {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk: I): Promise<void> {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined!;\n  stream._backpressureChangePromise = undefined!;\n  stream._backpressureChangePromise_resolve = undefined!;\n  TransformStreamSetBackpressure(stream, true);\n\n  stream._transformStreamController = undefined!;\n}\n\nfunction IsTransformStream(x: unknown): x is TransformStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return x instanceof TransformStream;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream: TransformStream, e: any) {\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream: TransformStream, e: any) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  TransformStreamUnblockWrite(stream);\n}\n\nfunction TransformStreamUnblockWrite(stream: TransformStream) {\n  if (stream._backpressure) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream: TransformStream, backpressure: boolean) {\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = newPromise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nexport class TransformStreamDefaultController<O> {\n  /** @internal */\n  _controlledTransformStream: TransformStream<any, O>;\n  /** @internal */\n  _finishPromise: Promise<undefined> | undefined;\n  /** @internal */\n  _finishPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _finishPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _transformAlgorithm: (chunk: any) => Promise<void>;\n  /** @internal */\n  _flushAlgorithm: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n   */\n  get desiredSize(): number | null {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n   */\n  enqueue(chunk: O): void;\n  enqueue(chunk: O = undefined!): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors both the readable side and the writable side of the controlled transform stream, making all future\n   * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n   */\n  error(reason: any = undefined): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  /**\n   * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n   * transformer only needs to consume a portion of the chunks written to the writable side.\n   */\n  terminate(): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  terminate: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nsetFunctionName(TransformStreamDefaultController.prototype.enqueue, 'enqueue');\nsetFunctionName(TransformStreamDefaultController.prototype.error, 'error');\nsetFunctionName(TransformStreamDefaultController.prototype.terminate, 'terminate');\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'TransformStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController<O = any>(x: any): x is TransformStreamDefaultController<O> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return x instanceof TransformStreamDefaultController;\n}\n\nfunction SetUpTransformStreamDefaultController<I, O>(stream: TransformStream<I, O>,\n                                                     controller: TransformStreamDefaultController<O>,\n                                                     transformAlgorithm: (chunk: I) => Promise<void>,\n                                                     flushAlgorithm: () => Promise<void>,\n                                                     cancelAlgorithm: (reason: any) => Promise<void>) {\n  assert(IsTransformStream(stream));\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._finishPromise = undefined;\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer<I, O>(stream: TransformStream<I, O>,\n                                                                    transformer: ValidatedTransformer<I, O>) {\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm: (chunk: I) => Promise<void>;\n  let flushAlgorithm: () => Promise<void>;\n  let cancelAlgorithm: (reason: any) => Promise<void>;\n\n  if (transformer.transform !== undefined) {\n    transformAlgorithm = chunk => transformer.transform!(chunk, controller);\n  } else {\n    transformAlgorithm = chunk => {\n      try {\n        TransformStreamDefaultControllerEnqueue(controller, chunk as unknown as O);\n        return promiseResolvedWith(undefined);\n      } catch (transformResultE) {\n        return promiseRejectedWith(transformResultE);\n      }\n    };\n  }\n\n  if (transformer.flush !== undefined) {\n    flushAlgorithm = () => transformer.flush!(controller);\n  } else {\n    flushAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  if (transformer.cancel !== undefined) {\n    cancelAlgorithm = reason => transformer.cancel!(reason);\n  } else {\n    cancelAlgorithm = () => promiseResolvedWith(undefined);\n  }\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller: TransformStreamDefaultController<any>) {\n  controller._transformAlgorithm = undefined!;\n  controller._flushAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\nfunction TransformStreamDefaultControllerEnqueue<O>(controller: TransformStreamDefaultController<O>, chunk: O) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller: TransformStreamDefaultController<any>, e: any) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform<I, O>(controller: TransformStreamDefaultController<O>,\n                                                                chunk: I) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate<O>(controller: TransformStreamDefaultController<O>) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController;\n\n  ReadableStreamDefaultControllerClose(readableController);\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm<I, O>(stream: TransformStream<I, O>, chunk: I): Promise<void> {\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return transformPromiseWith(backpressureChangePromise, () => {\n      const writable = stream._writable;\n      const state = writable._state;\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n      assert(state === 'writable');\n      return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm<I, O>(stream: TransformStream<I, O>, reason: any): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n  // we don't run the _cancelAlgorithm again.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const cancelPromise = controller._cancelAlgorithm(reason);\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(cancelPromise, () => {\n    if (readable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, readable._storedError);\n    } else {\n      ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm<I, O>(stream: TransformStream<I, O>): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n  // we don't also run the _cancelAlgorithm.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(flushPromise, () => {\n    if (readable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, readable._storedError);\n    } else {\n      ReadableStreamDefaultControllerClose(readable._readableStreamController);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream: TransformStream): Promise<void> {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\nfunction TransformStreamDefaultSourceCancelAlgorithm<I, O>(stream: TransformStream<I, O>, reason: any): Promise<void> {\n  const controller = stream._transformStreamController;\n  if (controller._finishPromise !== undefined) {\n    return controller._finishPromise;\n  }\n\n  // stream._writable cannot change after construction, so caching it across a call to user code is safe.\n  const writable = stream._writable;\n\n  // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or\n  // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the\n  // _flushAlgorithm.\n  controller._finishPromise = newPromise((resolve, reject) => {\n    controller._finishPromise_resolve = resolve;\n    controller._finishPromise_reject = reject;\n  });\n\n  const cancelPromise = controller._cancelAlgorithm(reason);\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  uponPromise(cancelPromise, () => {\n    if (writable._state === 'errored') {\n      defaultControllerFinishPromiseReject(controller, writable._storedError);\n    } else {\n      WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);\n      TransformStreamUnblockWrite(stream);\n      defaultControllerFinishPromiseResolve(controller);\n    }\n    return null;\n  }, r => {\n    WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);\n    TransformStreamUnblockWrite(stream);\n    defaultControllerFinishPromiseReject(controller, r);\n    return null;\n  });\n\n  return controller._finishPromise;\n}\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\nexport function defaultControllerFinishPromiseResolve(controller: TransformStreamDefaultController<any>) {\n  if (controller._finishPromise_resolve === undefined) {\n    return;\n  }\n\n  controller._finishPromise_resolve();\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\nexport function defaultControllerFinishPromiseReject(controller: TransformStreamDefaultController<any>, reason: any) {\n  if (controller._finishPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(controller._finishPromise!);\n  controller._finishPromise_reject(reason);\n  controller._finishPromise_resolve = undefined;\n  controller._finishPromise_reject = undefined;\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n","/* c8 ignore start */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\nif (!globalThis.ReadableStream) {\n  // `node:stream/web` got introduced in v16.5.0 as experimental\n  // and it's preferred over the polyfilled version. So we also\n  // suppress the warning that gets emitted by NodeJS for using it.\n  try {\n    const process = require('node:process')\n    const { emitWarning } = process\n    try {\n      process.emitWarning = () => {}\n      Object.assign(globalThis, require('node:stream/web'))\n      process.emitWarning = emitWarning\n    } catch (error) {\n      process.emitWarning = emitWarning\n      throw error\n    }\n  } catch (error) {\n    // fallback to polyfill implementation\n    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))\n  }\n}\n\ntry {\n  // Don't use node: prefix for this, require+node: is not supported until node v14.14\n  // Only `import()` can use prefix in 12.20 and later\n  const { Blob } = require('buffer')\n  if (Blob && !Blob.prototype.stream) {\n    Blob.prototype.stream = function name (params) {\n      let position = 0\n      const blob = this\n\n      return new ReadableStream({\n        type: 'bytes',\n        async pull (ctrl) {\n          const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE))\n          const buffer = await chunk.arrayBuffer()\n          position += buffer.byteLength\n          ctrl.enqueue(new Uint8Array(buffer))\n\n          if (position === blob.size) {\n            ctrl.close()\n          }\n        }\n      })\n    }\n  }\n} catch (error) {}\n/* c8 ignore end */\n","/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n\nif (!globalThis.DOMException) {\n  try {\n    const { MessageChannel } = require('worker_threads'),\n    port = new MessageChannel().port1,\n    ab = new ArrayBuffer()\n    port.postMessage(ab, [ab, ab])\n  } catch (err) {\n    err.constructor.name === 'DOMException' && (\n      globalThis.DOMException = err.constructor\n    )\n  }\n}\n\nmodule.exports = globalThis.DOMException\n","/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n","import Blob from './index.js'\n\nconst _File = class File extends Blob {\n  #lastModified = 0\n  #name = ''\n\n  /**\n   * @param {*[]} fileBits\n   * @param {string} fileName\n   * @param {{lastModified?: number, type?: string}} options\n   */// @ts-ignore\n  constructor (fileBits, fileName, options = {}) {\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)\n    }\n    super(fileBits, options)\n\n    if (options === null) options = {}\n\n    // Simulate WebIDL type casting for NaN value in lastModified option.\n    const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified)\n    if (!Number.isNaN(lastModified)) {\n      this.#lastModified = lastModified\n    }\n\n    this.#name = String(fileName)\n  }\n\n  get name () {\n    return this.#name\n  }\n\n  get lastModified () {\n    return this.#lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return !!object && object instanceof Blob &&\n      /^(File)$/.test(object[Symbol.toStringTag])\n  }\n}\n\n/** @type {typeof globalThis.File} */// @ts-ignore\nexport const File = _File\nexport default File\n","/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */\n\nimport C from 'fetch-blob'\nimport F from 'fetch-blob/file.js'\n\nvar {toStringTag:t,iterator:i,hasInstance:h}=Symbol,\nr=Math.random,\nm='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),\nf=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new F([b],c,b):b]:[a,b+'']),\ne=(c,f)=>(f?c:c.replace(/\\r?\\n|\\r/g,'\\r\\n')).replace(/\\n/g,'%0A').replace(/\\r/g,'%0D').replace(/\"/g,'%22'),\nx=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}}\n\nexport const File = F\n\n/** @type {typeof globalThis.FormData} */\nexport const FormData = class FormData {\n#d=[];\nconstructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}\nget [t]() {return 'FormData'}\n[i](){return this.entries()}\nstatic [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}\nappend(...a){x('append',arguments,2);this.#d.push(f(...a))}\ndelete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a)}\nget(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}\ngetAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}\nhas(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}\nforEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this)}\nset(...a){x('set',arguments,2);var b=[],c=!0;a=f(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d)});c&&b.push(a);this.#d=b}\n*entries(){yield*this.#d}\n*keys(){for(var[a]of this)yield a}\n*values(){for(var[,a]of this)yield a}}\n\n/** @param {FormData} F */\nexport function formDataToBlob (F,B=C){\nvar b=`${r()}${r()}`.replace(/\\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\\r\\nContent-Disposition: form-data; name=\"`\nF.forEach((v,n)=>typeof v=='string'\n?c.push(p+e(n)+`\"\\r\\n\\r\\n${v.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, '\\r\\n')}\\r\\n`)\n:c.push(p+e(n)+`\"; filename=\"${e(v.name, 1)}\"\\r\\nContent-Type: ${v.type||\"application/octet-stream\"}\\r\\n\\r\\n`, v, '\\r\\n'))\nc.push(`--${b}--`)\nreturn new B(c,{type:\"multipart/form-data; boundary=\"+b})}\n","import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n"]}